import express from "express";
import { ApolloServer } from "@apollo/server";
import { expressMiddleware } from "@apollo/server/express4";
import cors from "cors";
import { json } from "body-parser";
import { resolvers } from "./graphql/resolvers/query_resolvers";
import { loadFilesSync } from "@graphql-tools/load-files";
import { makeExecutableSchema } from "@graphql-tools/schema";
import { mergeTypeDefs } from "@graphql-tools/merge";
import * as jwt from "jsonwebtoken";
import { nanoid } from "nanoid";
import cookieParser from "cookie-parser";
import { prisma } from "./prisma/client";
import { authenticate } from "./authentication";
import { USER_SCOPES } from "./discord/oauth";
import { URLSearchParams } from "url";
import { APIUser } from "discord.js";
import { GraphqlRequestContext } from "./graphql/context";
import { DiscordApi } from "./discord/api";
import session from "express-session";
import { User } from "@prisma/client";

const host = process.env.HOST ?? "::1";
const port = process.env.PORT ? Number(process.env.PORT) : 3000;

// const BCRYPT_SALT_ROUNDS = 12;

const app = express();

app.use(cookieParser());
app.use(authenticate);

const sessionValue = {
  secret: process.env.SESSION_SECRET as string,
  cookie: { secure: false },
};

if (app.get("env") === "production") {
  app.set("trust proxy", 1); // trust first proxy
  sessionValue.cookie.secure = true; // serve secure cookies
}

app.use(session(sessionValue));

// Redirects to Discord OAuth, if user accepts goes to callback URL
app.get("/auth/discord/login", (req, res) => {
  const state = nanoid();
  const discord_base_url = "https://discord.com/api/oauth2";
  const params = new URLSearchParams({
    state,
    client_id: process.env.DISCORD_OAUTH_CLIENT_ID as string,
    redirect_uri: process.env.DISCORD_OAUTH_REDIRECT_URI as string,
    response_type: "code",
    scope: USER_SCOPES.join(" "),
  });

  const query = params.toString();

  const url = new URL(`/api/oauth2/authorize?${query}`, discord_base_url);

  res.cookie("oauth_state", state);

  res.redirect(url.toString());
});

// Discord Callback Route
app.get("/auth/discord/callback", async (req, res) => {
  const { code, state, error, error_description } = req.query;
  console.log(req.query);

  if (error) {
    res.status(401);
    res.send({ error: error, message: error_description });
    return;
  }

  // Protects against CSRF attacks
  if (state !== req.cookies.oauth_state) {
    res.status(401);
    res.send({
      error: "mismatched_state",
      message: "Oauth state does not match stored state of client.",
    });
    return;
  }

  if (!code) {
    res.status(401);
    res.send({ error: "no_code_provided", message: "No code provided." });
    return;
  }

  // Takes code generated by discord and sends it back to discord to get access token
  const discordResponse = await fetch("https://discord.com/api/oauth2/token", {
    method: "POST",
    body: new URLSearchParams({
      client_id: process.env.DISCORD_OAUTH_CLIENT_ID as string,
      client_secret: process.env.DISCORD_OAUTH_CLIENT_SECRET as string,
      grant_type: "authorization_code",
      redirect_uri: process.env.DISCORD_OAUTH_REDIRECT_URI as string,
      code: code as string,
      state: state as string,
    }),
    headers: {
      "Content-Type": "application/x-www-form-urlencoded",
      "Accept-Encoding": "application/x-www-form-urlencoded",
    },
  });

  const { access_token, refresh_token, token_type, expires_in, scope } =
    await discordResponse.json();

  // Start making requests to discord API using OAuth access token
  const userResponse = await fetch("https://discord.com/api/users/@me", {
    headers: {
      Authorization: `Bearer ${access_token}`,
    },
  });

  const { id, username, avatar, discriminator, email } = (await userResponse.json()) as APIUser;

  // TODO: Save user to database
  const user = await prisma.user.findFirst({
    where: { discordData: { discordId: id } },
  });

  // TODO: Encrypt using AES - NOT hashing
  // const encryptedAccessToken = await bcrypt.hash(
  //   access_token,
  //   BCRYPT_SALT_ROUNDS
  // );
  // const encryptedRefreshToken = await bcrypt.hash(
  //   refresh_token,
  //   BCRYPT_SALT_ROUNDS
  // );

  // TODO: Move this out of router into own service
  if (user == null) {
    await prisma.user.create({
      data: {
        discordData: {
          create: {
            discordId: id,
            username,
            avatar,
            discriminator,
            email,
          },
        },
        discordOauth: {
          create: {
            discordId: id,
            accessToken: access_token,
            refreshToken: refresh_token,
            tokenType: token_type,
            expiresIn: expires_in,
            scope,
          },
        },
      },
    });
  } else {
    await prisma.user.update({
      where: {
        id: user.id,
      },
      data: {
        discordData: {
          update: {
            discordId: id,
            username,
            avatar,
            discriminator,
            email,
          },
        },
        discordOauth: {
          upsert: {
            update: {
              accessToken: access_token,
              refreshToken: refresh_token,
              tokenType: token_type,
              expiresIn: expires_in,
              scope,
            },
            create: {
              discordId: id,
              accessToken: access_token,
              refreshToken: refresh_token,
              tokenType: token_type,
              expiresIn: expires_in,
              scope,
            },
          },
        },
      },
    });
  }

  // Creating a JWT
  const token = jwt.sign({ sub: id }, process.env.JWT_SECRET as string);

  res.cookie("token", token);

  res.redirect(process.env.CLIENT_REDIRECT_URL as string);
});

const typeDefs = mergeTypeDefs(
  loadFilesSync("./src/graphql", { recursive: true, extensions: [".graphql"] }),
);

const schema = makeExecutableSchema({
  typeDefs,
  resolvers,
});

const server = new ApolloServer<GraphqlRequestContext>({
  schema,
  formatError: (formattedError, error) => {
    console.log(error);

    return formattedError;
  },
});

server.start().then(() => {
  app.use(authenticate);
  app.use(
    "/graphql",
    cors<cors.CorsRequest>({
      origin: process.env.CLIENT_REDIRECT_URL,
      credentials: true,
    }),
    json(),
    expressMiddleware(server, {
      context: async ({ res }) => {
        const user: User | undefined = res.locals.user;

        return {
          currentUser: user,
          discordApi: user ? DiscordApi.forUser(res.locals.user) : undefined,
          clearCookie: (name: string) => res.clearCookie(name),
        };
      },
    }),
  );

  app.listen(port, host, () => {
    console.log(`[ API Ready ] http://${host}:${port}`);
  });
});
