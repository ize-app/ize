import express from "express";
import { ApolloServer } from "@apollo/server";
import { expressMiddleware } from "@apollo/server/express4";
import cors from "cors";
import { json } from "body-parser";
import { resolvers } from "./graphql/resolvers/query_resolvers";
import { loadFilesSync } from "@graphql-tools/load-files";
import { makeExecutableSchema } from "@graphql-tools/schema";
import { mergeTypeDefs } from "@graphql-tools/merge";
import * as jwt from "jsonwebtoken";
import { nanoid } from "nanoid";
import cookieParser from "cookie-parser";
import { prisma } from "./prisma/client";
import bcrypt from "bcrypt";
import { authenticate } from "./authentication";
import { APIUser } from 'discord-api-types/v10';

const host = process.env.HOST ?? "127.0.0.1";
const port = process.env.PORT ? Number(process.env.PORT) : 3000;

const BCRYPT_SALT_ROUNDS = 12;

const app = express();

app.use(cookieParser());
app.use(authenticate);

// Redirects to Discord OAuth, if user accepts goes to callback URL
app.get("/auth/discord/login", (req, res) => {
  const state = nanoid();

  const url = `https://discord.com/api/oauth2/authorize?client_id=1129641431057825844&redirect_uri=http%3A%2F%2Flocalhost%3A3000%2Fauth%2Fdiscord%2Fcallback&response_type=code&scope=identify&state=${state}`;

  res.cookie("oauth_state", state);

  res.redirect(url);
});

// Discord Callback Route
app.get("/auth/discord/callback", async (req, res) => {
  const { code, state } = req.query;

  if (state !== req.cookies.oauth_state) {
    // throw error
  }

  if (!code) {
    // throw error
  }

  // Takes code generated by discord and sends it back to discord to get access token
  const discordResponse = await fetch("https://discord.com/api/oauth2/token", {
    method: "POST",
    body: new URLSearchParams({
      client_id: process.env.DISCORD_OAUTH_CLIENT_ID,
      client_secret: process.env.DISCORD_OAUTH_CLIENT_SECRET,
      grant_type: "authorization_code",
      redirect_uri: process.env.DISCORD_OAUTH_REDIRECT_URI,
      code: code as string,
      state: state as string,
    }),
    headers: {
      "Content-Type": "application/x-www-form-urlencoded",
      "Accept-Encoding": "application/x-www-form-urlencoded",
    },
  });

  const { access_token, refresh_token, token_type, expires_in, scope } =
    await discordResponse.json();

  // Start making requests to discord API using OAuth access token
  const userResponse = await fetch("https://discord.com/api/users/@me", {
    headers: {
      Authorization: `Bearer ${access_token}`,
    },
  });

  const { id, username, avatar, discriminator, email } =
    await userResponse.json() as APIUser;

  // TODO: Save user to database
  const user = await prisma.user.findFirst({
    where: { discordData: { discordId: id } },
  });

  const encryptedAccessToken = await bcrypt.hash(
    access_token,
    BCRYPT_SALT_ROUNDS
  );
  const encryptedRefreshToken = await bcrypt.hash(
    refresh_token,
    BCRYPT_SALT_ROUNDS
  );

  if (user == null) {
    await prisma.user.create({
      data: {
        discordData: {
          create: {
            discordId: id,
            username,
            avatar,
            discriminator,
            email,
          },
        },
        discordOauth: {
          create: {
            accessToken: encryptedAccessToken,
            refreshToken: encryptedRefreshToken,
            tokenType: token_type,
            expiresIn: expires_in,
            scope,
          },
        },
      },
    });
  } else {
    await prisma.user.update({
      where: {
        id: user.id,
      },
      data: {
        discordData: {
          update: {
            discordId: id,
            username,
            avatar,
            discriminator,
            email,
          },
        },
        discordOauth: {
          upsert: {
            update: {
              accessToken: encryptedAccessToken,
              refreshToken: encryptedRefreshToken,
              tokenType: token_type,
              expiresIn: expires_in,
              scope,
            },
            create: {
              accessToken: encryptedAccessToken,
              refreshToken: encryptedRefreshToken,
              tokenType: token_type,
              expiresIn: expires_in,
              scope,
            },
          },
        },
      },
    });
  }

  // Creating a JWT
  const token = jwt.sign({ sub: id }, process.env.JWT_SECRET);

  res.cookie("token", token);

  res.redirect(process.env.CLIENT_REDIRECT_URL);
});

const typeDefs = mergeTypeDefs(
  loadFilesSync("./src/graphql", { recursive: true, extensions: [".graphql"] })
);

const schema = makeExecutableSchema({
  typeDefs,
  resolvers,
});

const server = new ApolloServer({
  schema,
});

server.start().then(() => {
  app.use(authenticate);
  app.use(
    "/graphql",
    cors<cors.CorsRequest>({
      origin: process.env.CLIENT_REDIRECT_URL,
      credentials: true,
    }),
    json(),
    expressMiddleware(server, {
      context: async ({ res }) => ({ currentUser: res.locals.user }),
    })
  );

  app.listen(port, host, () => {
    console.log(`[ API Ready ] http://${host}:${port}`);
  });
});
