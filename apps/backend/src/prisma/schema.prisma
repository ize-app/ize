// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id             String           @id @default(uuid()) @db.Uuid
  stytchId       String           @unique @map("stytch_id")
  firstName      String?
  lastName       String?
  createdAt      DateTime         @default(now()) @map("created_at")
  updatedAt      DateTime         @default(now()) @updatedAt @map("updated_at")
  Group          Group[]
  createdProcess ProcessVersion[]
  requests       Request[]
  responses      Response[]
  Identities     Identity[]
  Oauths         Oauths[]
  RequestNew     RequestNew[]
  ResponseNew    ResponseNew[]

  @@map("users")
}

model Identity {
  id        String   @id @default(uuid()) @db.Uuid
  userId    String?  @map("user_id") @db.Uuid
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @default(now()) @updatedAt @map("updated_at")
  // TODO make this field required
  entityId  String   @unique @map("entity_id") @db.Uuid

  User                        User?                       @relation(fields: [userId], references: [id], onDelete: Cascade)
  IdentityEmail               IdentityEmail?
  IdentityBlockchain          IdentityBlockchain?
  IdentityDiscord             IdentityDiscord?
  RoleIdentity                RoleIdentity[]
  IdentitiesGroups            IdentityGroup[]
  CustomGroupMemberIdentities CustomGroupMemberIdentity[]
  Entity                      Entity                      @relation(fields: [entityId], references: [id], onDelete: Cascade)

  @@map("identities")
}

model IdentityEmail {
  id         String   @id @default(uuid()) @db.Uuid
  identityId String   @unique @map("identity_id") @db.Uuid
  email      String   @unique
  icon       String?
  createdAt  DateTime @default(now()) @map("created_at")
  updatedAt  DateTime @default(now()) @updatedAt @map("updated_at")

  Identity Identity @relation(fields: [identityId], references: [id], onDelete: Cascade)

  @@map("identities_email")
}

model IdentityBlockchain {
  id         String   @id @default(uuid()) @db.Uuid
  identityId String   @unique @map("identity_id") @db.Uuid
  address    String   @unique
  ens        String?
  createdAt  DateTime @default(now()) @map("created_at")
  updatedAt  DateTime @default(now()) @updatedAt @map("updated_at")

  Identity Identity @relation(fields: [identityId], references: [id], onDelete: Cascade)

  @@map("identities_blockchain")
}

model IdentityDiscord {
  id            String   @id @default(uuid()) @db.Uuid
  identityId    String   @unique @map("identity_id") @db.Uuid
  discordUserId String   @map("discord_user_id")
  username      String
  discriminator String
  avatar        String?
  createdAt     DateTime @default(now()) @map("created_at")
  updatedAt     DateTime @default(now()) @updatedAt @map("updated_at")

  Identity Identity @relation(fields: [identityId], references: [id], onDelete: Cascade)

  @@map("identities_discord")
}

model IdentityGroup {
  identityId String   @map("identity_id") @db.Uuid
  groupId    String   @map("group_id") @db.Uuid
  active     Boolean
  createdAt  DateTime @default(now()) @map("created_at")
  updatedAt  DateTime @default(now()) @updatedAt @map("updated_at")

  Identity Identity @relation(fields: [identityId], references: [id], onDelete: Cascade)
  Group    Group    @relation(fields: [groupId], references: [id], onDelete: Cascade)

  @@unique([identityId, groupId])
  @@map("identities_groups")
}

enum OauthTypes {
  Discord
  Google
}

model Oauths {
  userId       String     @map("user_id") @db.Uuid
  type         OauthTypes
  accessToken  String     @map("access_token")
  refreshToken String     @map("refresh_token")
  idToken      String?    @map("id_token")
  scopes       Json[]
  expiresAt    DateTime?  @map("expires_at")
  createdAt    DateTime   @default(now()) @map("created_at")
  updatedAt    DateTime   @default(now()) @updatedAt @map("updated_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id(name: "id", [userId, type])
  @@map("oauths")
}

model Group {
  id                      String                   @id @default(uuid()) @db.Uuid
  creator                 User                     @relation(fields: [creatorId], references: [id])
  creatorId               String                   @map("creator_id") @db.Uuid
  entityId                String                   @unique @map("entity_id") @db.Uuid
  createdAt               DateTime                 @default(now()) @map("created_at")
  updatedAt               DateTime                 @default(now()) @updatedAt @map("updated_at")
  activeAt                DateTime?
  deactivatedat           DateTime?
  Entity                  Entity                   @relation(fields: [entityId], references: [id], onDelete: Cascade)
  GroupDiscordRole        GroupDiscordRole?
  process                 Process[]
  RoleGroups              RoleGroup[]
  GroupNft                GroupNft?
  IdentitiesGroups        IdentityGroup[]
  CustomGroupMemberGroups CustomGroupMemberGroup[]
  GroupCustom             GroupCustom?

  @@map("groups")
}

model GroupDiscordRole {
  id              String        @id @default(uuid()) @db.Uuid
  discordRoleId   String?       @map("discord_role_id")
  Group           Group         @relation(fields: [groupId], references: [id], onDelete: Cascade)
  groupId         String        @unique @map("group_id") @db.Uuid
  discordServer   DiscordServer @relation(fields: [discordServerId], references: [id], onDelete: Cascade)
  discordServerId String        @map("discord_server_id") @db.Uuid
  color           Int?
  name            String
  icon            String?
  unicodeEmoji    String?       @map("unicode_emoji")
  memberCount     Int?          @map("member_count")
  createdAt       DateTime      @default(now()) @map("created_at")
  updatedAt       DateTime      @default(now()) @updatedAt @map("updated_at")

  @@unique([discordServerId, discordRoleId])
  @@unique([discordServerId, name])
  @@map("discord_role_groups")
}

enum NftTypes {
  ERC721
  ERC1155
}

enum Blockchain {
  Ethereum
  Arbitrum
  Optimism
  Matic
  Base
}

model GroupCustom {
  id      String @id @default(uuid()) @db.Uuid
  name    String
  groupId String @unique @map("group_id") @db.Uuid

  group                       Group                       @relation(fields: [groupId], references: [id], onDelete: Cascade)
  CustomGroupMemberIdentities CustomGroupMemberIdentity[]
  CustomGroupMemberGroups     CustomGroupMemberGroup[]

  @@map("groups_custom")
}

model CustomGroupMemberGroup {
  groupId       String      @map("group_id") @db.Uuid
  groupCustomId String      @map("group_custom_id") @db.Uuid
  Group         Group       @relation(fields: [groupId], references: [id], onDelete: Cascade)
  GroupCustom   GroupCustom @relation(fields: [groupCustomId], references: [id], onDelete: Cascade)

  @@unique([groupId, groupCustomId])
  @@map("custom_group_group_members")
}

model CustomGroupMemberIdentity {
  identityId    String      @map("identity_id") @db.Uuid
  groupCustomId String      @map("group_custom_id") @db.Uuid
  Identity      Identity    @relation(fields: [identityId], references: [id], onDelete: Cascade)
  GroupCustom   GroupCustom @relation(fields: [groupCustomId], references: [id], onDelete: Cascade)

  @@unique([identityId, groupCustomId])
  @@map("custom_group_identity_members")
}

model GroupNft {
  id           String  @id @default(uuid()) @db.Uuid
  name         String
  icon         String?
  groupId      String  @unique @map("group_id") @db.Uuid
  collectionId String  @map("collection_id") @db.Uuid
  // null tokenId means that this group applies to all tokens in that collection
  tokenId      String? @map("token_id")

  Group         Group         @relation(fields: [groupId], references: [id], onDelete: Cascade)
  NftCollection NftCollection @relation(fields: [collectionId], references: [id], onDelete: Cascade)

  @@unique([collectionId, tokenId])
  @@map("groups_nft")
}

model NftCollection {
  id       String     @id @default(uuid()) @db.Uuid
  name     String?
  icon     String?
  chain    Blockchain
  type     NftTypes
  address  String
  GroupNft GroupNft[]

  @@unique([chain, address])
  @@map("nft_collection")
}

model DiscordServer {
  id               String             @id @default(uuid()) @db.Uuid
  discordServerId  String             @unique @map("discord_server_id")
  name             String
  icon             String?
  banner           String?
  createdAt        DateTime           @default(now()) @map("created_at")
  updatedAt        DateTime           @default(now()) @updatedAt @map("updated_at")
  GroupDiscordRole GroupDiscordRole[]

  @@map("discord_servers")
}

/// All details about how a process actually work are defined in process_versions. 
/// When process is changed, a new process_version record is changed
model Process {
  id                      String      @id @default(uuid()) @db.Uuid
  /// Group that this process is intrinsically tied to (optional)
  type                    ProcessType
  groupId                 String?     @map("group_id") @db.Uuid
  /// Process version record that is currently actice for this process
  currentProcessVersionId String?     @unique @map("current_process_version_id") @db.Uuid
  createdAt               DateTime    @default(now()) @map("created_at")
  updatedAt               DateTime    @default(now()) @updatedAt @map("updated_at")

  /// All process version records for the process
  processVersions        ProcessVersion[] @relation("Process")
  /// Current version of this process 
  currentProcessVersion  ProcessVersion?  @relation("CurrentProcess", fields: [currentProcessVersionId], references: [id])
  /// all of the evovle processes that give this process evolve rights
  evolveProcessRightsFor ProcessVersion[] @relation("EvolveProcess")
  childProcessVersions   ProcessVersion[] @relation("ParentProcess")
  group                  Group?           @relation(fields: [groupId], references: [id], onDelete: Cascade)

  @@map("processes")
}

enum ProcessType {
  Custom
  Evolve
}

/// Process versions describe all details of a how a process (options, inputs, decision systems, etc)
/// All parts of a process version (and its component tables) are immutable. When a process is changed, a new process version is created
model ProcessVersion {
  id                 String   @id @default(uuid()) @db.Uuid
  name               String
  description        String?
  /// Seconds after creation that request made by this process will expire
  expirationSeconds  Int      @map("expiration_seconds")
  /// Parent process for this process version 
  processId          String   @map("process_id") @db.Uuid
  creatorId          String   @map("creator_id") @db.Uuid
  optionSystemId     String   @map("option_system_id") @db.Uuid
  inputTemplateSetId String   @map("input_set_id") @db.Uuid
  actionId           String?  @map("action_id") @db.Uuid
  roleSetId          String   @map("role_set_id") @db.Uuid
  decisionSystemId   String   @map("decision_system_id") @db.Uuid
  evolveProcessId    String?  @map("evolve_process_id") @db.Uuid
  createdAt          DateTime @default(now()) @map("created_at")
  approved           Boolean  @default(false)
  parentProcessId    String?  @map("parent_process_id") @db.Uuid

  /// Parent process for this process version 
  process                  Process          @relation("Process", fields: [processId], references: [id], onDelete: Cascade)
  creator                  User             @relation(fields: [creatorId], references: [id], onDelete: Cascade)
  /// Process defined response options that are included on every request created by this process version
  optionSystem             OptionSystem     @relation(fields: [optionSystemId], references: [id], onDelete: Cascade)
  /// Template for the inputs that will be required on each new request created by this process version
  inputTemplateSet         InputTemplateSet @relation(fields: [inputTemplateSetId], references: [id], onDelete: Cascade)
  /// The action that is automatically run once a decision is reached
  action                   Action?          @relation(fields: [actionId], references: [id], onDelete: Cascade)
  /// The set of request/respond permissions for this process
  roleSet                  RoleSet          @relation(fields: [roleSetId], references: [id], onDelete: Cascade)
  /// System describing how responses to a request arrive at a decision
  decisionSystem           DecisionSystem   @relation(fields: [decisionSystemId], references: [id], onDelete: Cascade)
  /// The process that the ability to evolve this proess
  evolveProcess            Process?         @relation("EvolveProcess", fields: [evolveProcessId], references: [id], onDelete: Cascade)
  parentProcess            Process?         @relation("ParentProcess", fields: [parentProcessId], references: [id], onDelete: Cascade)
  ProcessForCurrentVersion Process?         @relation("CurrentProcess")

  /// All requests generated by this process version
  requests Request[]
  flowId   String?   @db.Uuid

  @@map("process_versions")
}

/// Option system describes how options will ultimately be presented to the respondant
/// This includes whether request/response can create their own options, data types on options, etc
model OptionSystem {
  id                        String         @id @default(uuid()) @db.Uuid
  /// Data type constraint placed globally across all options in this system
  dataType                  OptionDataType @map("data_type")
  defaultProcessOptionSetId String?        @map("default_process_option_set_id") @db.Uuid

  /// Options that will be included for every request generated by this process
  defaultProcessOptionSet OptionSet?       @relation(fields: [defaultProcessOptionSetId], references: [id], onDelete: Cascade)
  /// When an option set is created by a process, this lists all the process versions that use this option set
  processVersions         ProcessVersion[]

  @@map("option_systems")
}

/// Option sets are used to describe any list of options
/// Option sets can describe both option sets created in advance via the process and those defined on the request
model OptionSet {
  id        String   @id @default(uuid()) @db.Uuid
  createdAt DateTime @default(now()) @map("created_at")

  /// All of the options that are part of this option set
  options       Option[]
  /// When a request creates new options on the fly, this points to which request created that option set
  request       Request?
  /// Option systems that use this option set
  optionSystems OptionSystem[]

  @@map("option_sets")
}

/// An individual option that a respoondant will be able to select on a request
model Option {
  id          String         @id @default(uuid()) @db.Uuid
  value       String
  /// Type changes both how a given option is presented in the UI and form validation
  type        OptionDataType
  /// Relative order that an option should appear relative to other options
  position    Int
  optionSetId String         @map("option_set_id") @db.Uuid
  optionSet   OptionSet      @relation(fields: [optionSetId], references: [id], onDelete: Cascade)
  createdAt   DateTime       @default(now()) @map("created_at")

  /// Responses that selected this option
  response Response[]
  /// Final decisions that selected this option
  results  Result[]
  action   Action[]

  @@map("options")
}

enum OptionDataType {
  Int
  Float
  Text
  Uri

  @@map("option_data_types")
}

/// A set of ordered inputs that the process solicits from the creator of a request
model InputTemplateSet {
  id        String   @id @default(uuid()) @db.Uuid
  createdAt DateTime @default(now()) @map("created_at")

  /// Processes thatt use this input template set
  processVersions ProcessVersion[]
  /// All user inputs
  inputTemplates  InputTemplate[]

  @@map("input_template_sets")
}

/// Parameters for a single input that a process solicits from the creator a request
model InputTemplate {
  id                 String                @id @default(uuid()) @db.Uuid
  createdAt          DateTime              @default(now()) @map("created_at")
  name               String
  /// Order that input should be displayed relative to other inputs
  position           Int
  type               InputTemplateDataType
  /// Descrbes how type of input that process is asking for in the request (e.g. examples, additional explaination, etc) 
  description        String?
  /// Whether a user will be required to fill out this input to create a request
  required           Boolean
  inputTemplateSetId String                @map("input_template_set_id") @db.Uuid

  inputTemplateSet InputTemplateSet @relation(fields: [inputTemplateSetId], references: [id], onDelete: Cascade)
  /// Requests that used this particular input
  requestInputs    RequestInput[]

  @@map("input_templates")
}

enum InputTemplateDataType {
  Int
  Float
  Text
  Uri
  StringArray

  @@map("input_template_data_types")
}

/// Action that is automatically executed when a request arrives at a decision
model Action {
  id        String     @id @default(uuid()) @db.Uuid
  type      ActionType
  /// Option Id here refers to whether execution of this action can only happen when a certain option is selected as the result
  /// A null value means thatfE there is no filter and action will be executed regardless of the result
  optionId  String?    @map("option_id") @db.Uuid
  createdAt DateTime   @default(now()) @map("created_at")

  option          Option?          @relation(fields: [optionId], references: [id], onDelete: Cascade)
  /// Process versions that use this action
  processVersions ProcessVersion[]
  actionAttempts  ActionAttempt[]
  webhookAction   WebhookAction?

  @@map("actions")
}

model ActionAttempt {
  id        String   @id @default(uuid()) @db.Uuid
  success   Boolean
  actionId  String   @map("action_id") @db.Uuid
  resultId  String   @map("result_id") @db.Uuid
  createdAt DateTime @default(now()) @map("created_at")

  result Result @relation(fields: [resultId], references: [id], onDelete: Cascade)
  action Action @relation(fields: [actionId], references: [id], onDelete: Cascade)

  @@map("action_attempts")
}

model WebhookAction {
  id       String @id @default(uuid()) @db.Uuid
  uri      String
  actionId String @unique @map("action_id") @db.Uuid

  action Action @relation(fields: [actionId], references: [id], onDelete: Cascade)

  @@map("webhook_actions")
}

enum ActionType {
  customWebhook
  evolveProcess

  @@map("action_types")
}

/// Role sets are a list of users with Request/Repsond privleges for a given process version. 
/// Both groups and individual users can be given roles. 
model RoleSet {
  id             String           @id @default(uuid()) @db.Uuid
  createdAt      DateTime         @default(now()) @map("created_at")
  processVersion ProcessVersion[]
  RoleIdentities RoleIdentity[]
  RoleGroups     RoleGroup[]

  @@map("role_sets")
}

model RoleIdentity {
  id         String   @id @default(uuid()) @db.Uuid
  identityId String   @map("user_id") @db.Uuid
  roleSetId  String   @map("role_set_id") @db.Uuid
  type       RoleType
  createdAt  DateTime @default(now()) @map("created_at")

  Identity Identity @relation(fields: [identityId], references: [id], onDelete: Cascade)
  RoleSet  RoleSet  @relation(fields: [roleSetId], references: [id], onDelete: Cascade)

  @@map("role_identities")
}

model RoleGroup {
  id        String   @id @default(uuid()) @db.Uuid
  groupId   String   @map("group_id") @db.Uuid
  roleSetId String   @map("role_set_id") @db.Uuid
  type      RoleType
  createdAt DateTime @default(now()) @map("created_at")

  Group   Group   @relation(fields: [groupId], references: [id], onDelete: Cascade)
  RoleSet RoleSet @relation(fields: [roleSetId], references: [id], onDelete: Cascade)

  @@map("role_groups")
}

enum RoleType {
  Request
  Respond
}

/// Decision systems describe how individual responses are translated into a final decision
model DecisionSystem {
  id                       String                    @id @default(uuid()) @db.Uuid
  type                     DecisionSystemTypes
  createdAt                DateTime                  @default(now()) @map("created_at")
  processVersions          ProcessVersion[]
  absoluteDecisionSystem   AbsoluteDecisionSystem?
  percentageDecisionSystem PercentageDecisionSystem?

  @@map("decision_systems")
}

enum DecisionSystemTypes {
  Absolute
  Percentage
}

/// Absoluate decision system is when a decision is reached once an option receives an threshold # of responses
model AbsoluteDecisionSystem {
  id               String   @id @default(uuid()) @db.Uuid
  decisionSystemId String   @unique @map("decision_system_id") @db.Uuid
  createdAt        DateTime @default(now()) @map("created_at")
  threshold        Int

  decisionSystem DecisionSystem @relation(fields: [decisionSystemId], references: [id], onDelete: Cascade)

  @@map("absolute_decision_systems")
}

/// Percentage decision system chooses a winner once an option acheives a threshold % of total votes and qurorum is acheived
model PercentageDecisionSystem {
  id               String   @id @default(uuid()) @db.Uuid
  decisionSystemId String   @unique @map("decision_system_id") @db.Uuid
  createdAt        DateTime @default(now()) @map("created_at")
  percentage       Float
  quorum           Int

  decisionSystem DecisionSystem @relation(fields: [decisionSystemId], references: [id], onDelete: Cascade)

  @@map("percentage_decision_systems")
}

/// An instance of a process being used
model Request {
  id               String   @id @default(uuid()) @db.Uuid
  processVersionId String   @map("process_version_id") @db.Uuid
  creatorId        String   @map("creator_id") @db.Uuid
  expirationDate   DateTime @map("expiration_date")
  optionSetId      String?  @unique @map("option_set_ids") @db.Uuid
  createdAt        DateTime @default(now()) @map("created_at")
  updatedAt        DateTime @default(now()) @updatedAt @map("updated_at")

  /// Refers to options that can be created by the requestor. The process may also have default options
  optionSet      OptionSet?     @relation(fields: [optionSetId], references: [id], onDelete: Cascade)
  /// Process version that produced this request
  processVersion ProcessVersion @relation(fields: [processVersionId], references: [id], onDelete: Cascade)
  /// Creator of this request
  creator        User           @relation(fields: [creatorId], references: [id], onDelete: Cascade)

  requestInputs RequestInput[]
  responses     Response[]
  result        Result?

  @@map("requests")
}

/// While the Input Template defines the parameters of inputs on each request, the Request Input is the actual input 
model RequestInput {
  id        String   @id @default(uuid()) @db.Uuid
  requestId String   @map("request_id") @db.Uuid
  inputId   String   @map("input_id") @db.Uuid
  createdAt DateTime @default(now()) @map("created_at")
  value     String

  request Request       @relation(fields: [requestId], references: [id], onDelete: Cascade)
  input   InputTemplate @relation(fields: [inputId], references: [id], onDelete: Cascade)

  @@map("request_inputs")
}

/// Response to a request
model Response {
  id        String   @id @default(uuid()) @db.Uuid
  requestId String   @map("request_id") @db.Uuid
  creatorId String   @map("creator_id") @db.Uuid
  optionId  String   @map("option_id") @db.Uuid
  createdAt DateTime @default(now()) @map("created_at")

  option  Option  @relation(fields: [optionId], references: [id], onDelete: Cascade)
  request Request @relation(fields: [requestId], references: [id], onDelete: Cascade)
  creator User    @relation(fields: [creatorId], references: [id])

  @@map("responses")
}

/// Final decision for a request
model Result {
  id        String   @id @default(uuid()) @db.Uuid
  requestId String   @unique @map("request_id") @db.Uuid
  optionId  String   @map("option_id") @db.Uuid
  createdAt DateTime @default(now()) @map("created_at")

  option         Option          @relation(fields: [optionId], references: [id], onDelete: Cascade)
  request        Request         @relation(fields: [requestId], references: [id], onDelete: Cascade)
  actionAttempts ActionAttempt[]

  @@map("results")
}

model Flow {
  id        String  @id @default(uuid()) @db.Uuid
  reusable  Boolean
  requestId String  @unique @map("request_id") @db.Uuid

  currentFlowVersionId String @unique @map("current_flow_version_id") @db.Uuid

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @default(now()) @updatedAt @map("updated_at")

  CurrentFlowVersion         FlowVersion?  @relation("FlowToCurrentFlowVersion", fields: [currentFlowVersionId], references: [id])
  FlowVersions               FlowVersion[] @relation("FlowToAllFlowVersions")
  EvolveRightsFoFlowVersions FlowVersion[] @relation("EvolveFlowToFlowVersions")

  @@map("flows")
}

model FlowVersion {
  id                       String @id @default(uuid()) @db.Uuid
  name                     String
  requestExpirationSeconds Int    @map("request_expiration_seconds")
  flowId                   String @map("flow_id") @db.Uuid
  // the evolve flow id gives evolve flow edit rights over all steps in the flow
  evolveFlowId             String @map("evolve_flow_id") @db.Uuid

  createdAt DateTime @default(now()) @map("created_at")

  FlowForCurrentVersion Flow? @relation("FlowToCurrentFlowVersion")
  Flow                  Flow  @relation("FlowToAllFlowVersions", fields: [flowId], references: [id], onDelete: Cascade)
  EvolveFlow            Flow? @relation("EvolveFlowToFlowVersions", fields: [evolveFlowId], references: [id], onDelete: Cascade)

  @@map("flow_versions")
}

// Note: In this current model, steps are tied to a given workflow,
// If in the future, we wanted to allow steps to be reusable by different flows while preserving flow data immutability,
// we'd need to create a steps_versions_model and flows_versions_steps model.
// Too much complexity for v1
model Step {
  id   String @id @default(uuid()) @db.Uuid
  name String

  requestPermissionsId  String   @map("request_permissions_id") @db.Uuid
  responsePermissionsId String   @map("response_permissions_id") @db.Uuid
  requestFieldSetId     String   @map("request_field_set_id") @db.Uuid
  responseFieldSetId    String   @map("response_field_set_id") @db.Uuid
  resultConfigId        String   @map("result_config_id") @db.Uuid
  actionId              String   @map("action_id") @db.Uuid
  createdAt             DateTime @default(now()) @map("created_at")

  RequestPermissions     Permission   @relation("RequestPermissions", fields: [requestPermissionsId], references: [id], onDelete: Cascade)
  RequestFieldSet        FieldSet     @relation("RequestFieldSet", fields: [requestFieldSetId], references: [id], onDelete: Cascade)
  ResponseFieldSet       FieldSet     @relation("ResponseFieldSet", fields: [responseFieldSetId], references: [id], onDelete: Cascade)
  ResponsePermissions    Permission   @relation("ResponsePermissions", fields: [responsePermissionsId], references: [id], onDelete: Cascade)
  TriggerStepPermissions Permission[] @relation("TriggeringStepPermissions")
  ResultConfig           ResultConfig @relation(fields: [resultConfigId], references: [id], onDelete: Cascade)
  ActionNew              ActionNew    @relation("StepsWithAction", fields: [actionId], references: [id], onDelete: Cascade)
  ActionTriggers         ActionNew[]  @relation("TriggerStep")

  @@map("steps")
}

model Permission {
  id String @id @default(uuid()) @db.Uuid

  entitySetId      String?  @map("entity_set_id") @db.Uuid
  triggeringStepId String?  @map("triggering_step_id") @db.Uuid
  anyone           Boolean  @default(false)
  createdAt        DateTime @default(now()) @map("created_at")

  EntitySet                EntitySet? @relation(fields: [entitySetId], references: [id], onDelete: Cascade)
  RequestPermissionsSteps  Step[]     @relation("RequestPermissions")
  ResponsePermissionsSteps Step[]     @relation("ResponsePermissions")
  TriggeringStep           Step?      @relation("TriggeringStepPermissions", fields: [triggeringStepId], references: [id], onDelete: Cascade)

  @@map("permissions")
}

model EntitySet {
  id                String              @id @default(uuid()) @db.Uuid
  Permissions       Permission[]
  createdAt         DateTime            @default(now()) @map("created_at")
  EntitySetEntities EntitySetEntities[]

  @@map("entity_sets")
}

model EntitySetEntities {
  entitySetId String @map("entity_set_id") @db.Uuid
  entityId    String @map("entity_id") @db.Uuid

  EntitySet EntitySet @relation(fields: [entitySetId], references: [id], onDelete: Cascade)
  Entity    Entity    @relation(fields: [entityId], references: [id], onDelete: Cascade)

  @@unique([entityId, entitySetId])
  @@map("entity_set_entities")
}

// Entities are anything that can be assigned a role. 
// For now, that's goups and identities
model Entity {
  id        String   @id @default(uuid()) @db.Uuid
  createdAt DateTime @default(now()) @map("created_at")

  Group             Group?
  Identity          Identity?
  EntitySetEntities EntitySetEntities[]

  @@map("entities")
}

// List of fields for use in request or response
model FieldSet {
  id                              String            @id @default(uuid()) @db.Uuid
  createdAt                       DateTime          @default(now()) @map("created_at")
  StepsRequestsUsingThisFieldSet  Step[]            @relation("RequestFieldSet")
  StepsResponsesUsingThisFieldSet Step[]            @relation("ResponseFieldSet")
  FieldSetFields                  FieldSetsFields[]

  @@map("field_sets")
}

// Purpose of this association table is so that there can be new sets of options without 
// needing to create new fields everytime there's a change to the group (since data is immutable in Ize)
model FieldSetsFields {
  fieldSetId String @map("field_set_id") @db.Uuid
  fieldId    String @map("field_id") @db.Uuid

  FieldSet FieldSet @relation(fields: [fieldSetId], references: [id], onDelete: Cascade)
  Field    Field    @relation(fields: [fieldId], references: [id], onDelete: Cascade)

  @@unique([fieldId, fieldSetId])
  @@map("field_sets_fields")
}

enum FieldDataType {
  String
  Number
  Uri
  Date
  DateTime
}

enum FieldType {
  Options
  FreeInput
}

// Describes a single ask for a users input (e.g. select an option)
model Field {
  id                   String         @id @default(uuid()) @db.Uuid
  type                 FieldType
  name                 String
  required             Boolean        @default(true)
  freeInputDataType    FieldDataType? @map("free_input_data_type")
  fieldOptionsConfigId String?        @map("field_options_config_id") @db.Uuid
  createdAt            DateTime       @default(now()) @map("created_at")

  FieldOptionsConfigs FieldOptionsConfig? @relation(fields: [fieldOptionsConfigId], references: [id])
  Answers             Answer[]
  ResultConfig        ResultConfig[]
  FieldSetFields      FieldSetsFields[]

  @@map("fields")
}

enum OptionSelectionType {
  Rank
  MultiSelect
  Select
}

// Describes how a set of options are created on a request 
model FieldOptionsConfig {
  id                     String              @id @default(uuid()) @db.Uuid
  fieldOptionSetId       String              @map("field_option_set_id") @db.Uuid
  requestOptionsDataType FieldDataType?      @map("data_type")
  // Whether or not options are created by the requestor
  hasRequestOptions      Boolean             @default(false) @map("has_request_options")
  // Whether option is single or multi-select
  maxSelections          Int                 @map("max_selections")
  // type single select / multi-select / etc
  selectionType          OptionSelectionType @map("option_selection_type")
  createdAt              DateTime            @default(now()) @map("created_at")

  Field          Field[]
  FieldOptionSet FieldOptionSet @relation(fields: [fieldOptionSetId], references: [id], onDelete: Cascade)

  @@map("field_options_configs")
}

model FieldOptionSet {
  id        String   @id @default(uuid()) @db.Uuid
  createdAt DateTime @default(now()) @map("created_at")

  FieldOptionsConfigs        FieldOptionsConfig[]
  FieldOptionSetFieldOptions FieldOptionSetsFieldOptions[]
  RequestNew                 RequestNew[]

  @@map("field_option_sets")
}

// Purpose of this association table is so that there can be new sets of options without 
// needing to create new options everytime there's a change to the group (since data is immutable in Ize)
// This makes showing diffs between flow versions much eaiser
model FieldOptionSetsFieldOptions {
  fieldOptionSetId String @map("field_option_set_id") @db.Uuid
  fieldOptionId    String @map("field_option_id") @db.Uuid

  FieldOptionSet FieldOptionSet @relation(fields: [fieldOptionSetId], references: [id], onDelete: Cascade)
  FieldOption    FieldOption    @relation(fields: [fieldOptionId], references: [id], onDelete: Cascade)

  @@unique([fieldOptionId, fieldOptionSetId])
  @@map("field_option_set_field_options")
}

model FieldOption {
  id        String        @id @default(uuid()) @db.Uuid
  dataType  FieldDataType @map("data_type")
  value     String
  createdAt DateTime      @default(now()) @map("created_at")

  AnswerOptionSelections     AnswerOptionSelection[]
  FieldOptionSetFieldOptions FieldOptionSetsFieldOptions[]
  DefaultOptionForDecisions  ResultConfigDecision[]
  ActionNew                  ActionNew[]

  @@map("field_options")
}

model Answer {
  id                String    @id @default(uuid()) @db.Uuid
  type              FieldType
  responseId        String?   @map("response_id") @db.Uuid
  requestId         String?   @map("request_id") @db.Uuid
  fieldId           String    @map("field_id") @db.Uuid
  answerFreeInputId String    @map("answer_free_input_id") @db.Uuid
  createdAt         DateTime  @default(now()) @map("created_at")

  Field                  Field                   @relation(fields: [fieldId], references: [id], onDelete: Cascade)
  Response               ResponseNew?            @relation(fields: [responseId], references: [id], onDelete: Cascade)
  Request                RequestNew?             @relation(fields: [requestId], references: [id], onDelete: Cascade)
  AnswerOptionSelections AnswerOptionSelection[]
  AnswerFreeInput        AnswerFreeInput         @relation(fields: [answerFreeInputId], references: [id], onDelete: Cascade)

  @@map("answers")
}

model AnswerOptionSelection {
  id                String   @id @default(uuid()) @db.Uuid
  fieldAnswerId     String   @map("field_answer_id") @db.Uuid
  fieldOptionId     String   @map("field_option_id") @db.Uuid
  answerFreeInputId String   @map("answer_free_input_id") @db.Uuid
  createdAt         DateTime @default(now()) @map("created_at")

  FieldOption     FieldOption     @relation(fields: [fieldOptionId], references: [id], onDelete: Cascade)
  Answer          Answer          @relation(fields: [fieldAnswerId], references: [id], onDelete: Cascade)
  AnswerFreeInput AnswerFreeInput @relation(fields: [answerFreeInputId], references: [id], onDelete: Cascade)

  @@map("answer_option_selections")
}

model AnswerFreeInput {
  id        String        @id @default(uuid()) @db.Uuid
  dataType  FieldDataType @map("data_type")
  value     String
  createdAt DateTime      @default(now()) @map("created_at")

  AnswerOptionSelections AnswerOptionSelection[]
  Answer                 Answer[]

  @@map("answer_free_inputs")
}

enum ResultType {
  Raw
  Decision
  Prioritization
  LlmSummary
  AutoApprove
}

// Describes how and when a final result is created
model ResultConfig {
  id         String        @id @default(uuid()) @db.Uuid
  dataType   FieldDataType @map("data_type")
  resultType ResultType    @map("result_type")
  // Minimum answers for a result to be created
  minAnswers Int           @default(1) @map("min_answers")
  // whether output will be a single item or a list of items
  isList     Boolean       @map("is_list")
  createdAt  DateTime      @default(now()) @map("created_at")

  fieldId    String  @map("field_id") @db.Uuid
  decisionId String? @map("decision_id") @db.Uuid
  rankId     String? @map("rank_id") @db.Uuid
  llmId      String? @map("llm_id") @db.Uuid

  Field                Field                 @relation(fields: [fieldId], references: [id], onDelete: Cascade)
  ResultConfigDecision ResultConfigDecision? @relation(fields: [decisionId], references: [id], onDelete: Cascade)
  ResultConfigRank     ResultConfigRank?     @relation(fields: [rankId], references: [id], onDelete: Cascade)
  ResultConfigLlm      ResultConfigLlm?      @relation(fields: [llmId], references: [id], onDelete: Cascade)
  Steps                Step[]
  Results              Results[]

  @@map("result_configs")
}

enum DecisionType {
  NumberThreshold
  PercentageThreshold
}

model ResultConfigDecision {
  id              String       @id @default(uuid()) @db.Uuid
  type            DecisionType
  defaultOptionId String       @map("default_option_id") @db.Uuid
  // Threshold is interpreted as count when type is "threshold" and as a percentage when type is "Percentage"
  threshold       Int          @map("threshold")
  createdAt       DateTime     @default(now()) @map("created_at")

  FieldOption   FieldOption    @relation(fields: [defaultOptionId], references: [id], onDelete: Cascade)
  ResultConfigs ResultConfig[]

  @@map("result_config_decisions")
}

model ResultConfigRank {
  id            String         @id @default(uuid()) @db.Uuid
  // null means include all options
  numOptions    Int?           @map("num_options")
  createdAt     DateTime       @default(now()) @map("created_at")
  ResultConfigs ResultConfig[]

  @@map("result_config_rankings")
}

model ResultConfigLlm {
  id        String   @id @default(uuid()) @db.Uuid
  prompt    String
  createdAt DateTime @default(now()) @map("created_at")

  ResultConfigs ResultConfig[]

  @@map("result_config_llms")
}

enum ActionNewType {
  CallWebhook
  TriggerStep
}

model ActionNew {
  id             String        @id @default(uuid()) @db.Uuid
  type           ActionNewType
  triggerStepId  String        @map("trigger_step_id") @db.Uuid
  webhookId      String        @map("webhook_id") @db.Uuid
  filterOptionId String        @map("filter_option_id") @db.Uuid
  createdAt      DateTime      @default(now()) @map("created_at")

  Steps             Step[]             @relation("StepsWithAction")
  FieldOption       FieldOption        @relation(fields: [filterOptionId], references: [id], onDelete: Cascade)
  ActionWebhook     ActionWebhook      @relation(fields: [webhookId], references: [id], onDelete: Cascade)
  TriggerStep       Step               @relation("TriggerStep", fields: [triggerStepId], references: [id], onDelete: Cascade)
  ActionAttemptsNew ActionAttemptNew[]

  @@map("actions_new")
}

model ActionWebhook {
  id        String   @id @default(uuid()) @db.Uuid
  name      String
  url       String
  createdAt DateTime @default(now()) @map("created_at")

  ActionsNew ActionNew[]

  @@map("action_webhooks")
}

model ActionAttemptNew {
  id        String   @id @default(uuid()) @db.Uuid
  actionId  String   @map("action_id") @db.Uuid
  success   Boolean
  createdAt DateTime @default(now()) @map("created_at")

  Action ActionNew @relation(fields: [actionId], references: [id], onDelete: Cascade)

  @@map("action_attempts_new")
}

model RequestNew {
  id                 String   @id @default(uuid()) @db.Uuid
  creatorId          String   @map("creator_id") @db.Uuid
  expirationDate     DateTime @map("expiration_date")
  requestOptionSetId String   @db.Uuid
  open               Boolean  @default(true)
  createdAt          DateTime @default(now()) @map("created_at")
  updatedAt          DateTime @default(now()) @updatedAt @map("updated_at")

  Answers          Answer[]
  User             User           @relation(fields: [creatorId], references: [id])
  Results          Results[]
  // For when the options are request are created by the requestor or the previous step
  RequestOptionSet FieldOptionSet @relation(fields: [requestOptionSetId], references: [id])

  @@map("requests_new")
}

model ResponseNew {
  id        String   @id @default(uuid()) @db.Uuid
  creatorId String   @map("creator_id") @db.Uuid
  createdAt DateTime @default(now()) @map("created_at")

  Answers Answer[]
  User    User     @relation(fields: [creatorId], references: [id])

  @@map("responses_new")
}

// can have multiple results for a given result config
model Results {
  id             String   @id @default(uuid()) @db.Uuid
  requestId      String   @map("request_id") @db.Uuid
  resultConfigId String   @map("result_config_id") @db.Uuid
  createdAt      DateTime @default(now()) @map("created_at")

  Request      RequestNew   @relation(fields: [requestId], references: [id])
  ResultConfig ResultConfig @relation(fields: [resultConfigId], references: [id])

  @@map("results_new")
}
