generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["fullTextSearch"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        String   @id @default(uuid()) @db.Uuid
  stytchId  String   @unique @map("stytch_id")
  entityId  String   @unique @map("entity_id") @db.Uuid
  name      String   @default("")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @default(now()) @updatedAt @map("updated_at")

  Identities Identity[]
  Oauths     Oauths[]
  Entity     Entity     @relation(fields: [entityId], references: [id], onDelete: Cascade)

  @@map("users")
}

model Identity {
  id        String   @id @default(uuid()) @db.Uuid
  userId    String?  @map("user_id") @db.Uuid
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @default(now()) @updatedAt @map("updated_at")
  // TODO make this field required
  entityId  String   @unique @map("entity_id") @db.Uuid

  User               User?               @relation(fields: [userId], references: [id])
  IdentityEmail      IdentityEmail?
  IdentityBlockchain IdentityBlockchain?
  IdentityDiscord    IdentityDiscord?
  IdentitiesGroups   IdentityGroup[]
  Entity             Entity              @relation(fields: [entityId], references: [id], onDelete: Cascade)
  IdentityTelegram   IdentityTelegram?

  @@map("identities")
}

model IdentityEmail {
  id         String   @id @default(uuid()) @db.Uuid
  identityId String   @unique @map("identity_id") @db.Uuid
  email      String   @unique
  icon       String?
  createdAt  DateTime @default(now()) @map("created_at")
  updatedAt  DateTime @default(now()) @updatedAt @map("updated_at")

  Identity Identity @relation(fields: [identityId], references: [id], onDelete: Cascade)

  @@map("identities_email")
}

model IdentityBlockchain {
  id         String   @id @default(uuid()) @db.Uuid
  identityId String   @unique @map("identity_id") @db.Uuid
  address    String   @unique
  ens        String?
  createdAt  DateTime @default(now()) @map("created_at")
  updatedAt  DateTime @default(now()) @updatedAt @map("updated_at")

  Identity Identity @relation(fields: [identityId], references: [id], onDelete: Cascade)

  @@map("identities_blockchain")
}

model IdentityDiscord {
  id            String   @id @default(uuid()) @db.Uuid
  identityId    String   @unique @map("identity_id") @db.Uuid
  discordUserId String   @map("discord_user_id")
  username      String
  discriminator String
  avatar        String?
  createdAt     DateTime @default(now()) @map("created_at")
  updatedAt     DateTime @default(now()) @updatedAt @map("updated_at")

  Identity Identity @relation(fields: [identityId], references: [id], onDelete: Cascade)

  @@map("identities_discord")
}

model IdentityTelegram {
  id             String  @id @default(uuid()) @db.Uuid
  identityId     String  @unique @map("identity_id") @db.Uuid
  telegramUserId BigInt  @unique @map("telegram_user_id")
  username       String?
  photoUrl       String? @map("photo_url")
  firstName      String  @map("first_name")
  lastName       String? @map("last_name")

  Identity Identity @relation(fields: [identityId], references: [id], onDelete: Cascade)

  @@map("identities_telegram")
}

model IdentityGroup {
  identityId String   @map("identity_id") @db.Uuid
  groupId    String   @map("group_id") @db.Uuid
  active     Boolean
  createdAt  DateTime @default(now()) @map("created_at")
  updatedAt  DateTime @default(now()) @updatedAt @map("updated_at")

  Identity Identity @relation(fields: [identityId], references: [id], onDelete: Cascade)
  Group    Group    @relation(fields: [groupId], references: [id], onDelete: Cascade)

  @@unique([identityId, groupId])
  @@map("identities_groups")
}

enum OauthTypes {
  Discord
  Google
}

model Oauths {
  userId       String     @map("user_id") @db.Uuid
  type         OauthTypes
  accessToken  String     @map("access_token")
  refreshToken String     @map("refresh_token")
  idToken      String?    @map("id_token")
  scopes       Json[]
  expiresAt    DateTime?  @map("expires_at")
  createdAt    DateTime   @default(now()) @map("created_at")
  updatedAt    DateTime   @default(now()) @updatedAt @map("updated_at")

  User User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id(name: "id", [userId, type])
  @@map("oauths")
}

enum GroupType {
  DiscordRoleGroup
  GroupNft
  GroupTelegram
  GroupCustom
}

model Group {
  id                  String                @id @default(uuid()) @db.Uuid
  creatorEntityId     String                @map("creator_entity_id") @db.Uuid
  entityId            String                @unique @map("entity_id") @db.Uuid
  createdAt           DateTime              @default(now()) @map("created_at")
  updatedAt           DateTime              @default(now()) @updatedAt @map("updated_at")
  activeAt            DateTime?
  deactivatedAt       DateTime?
  type                GroupType
  Entity              Entity                @relation(fields: [entityId], references: [id], onDelete: Cascade)
  Creator             Entity                @relation("Creator", fields: [creatorEntityId], references: [id])
  GroupDiscordRole    GroupDiscordRole?
  GroupNft            GroupNft?
  GroupTelegramChat   GroupTelegramChat?
  IdentitiesGroups    IdentityGroup[]
  GroupCustom         GroupCustom?
  EntityWatchedGroups EntityWatchedGroups[]
  OwnedFlows          Flow[]
  GroupsWatchedFlows  GroupsWatchedFlows[]

  @@map("groups")
}

model GroupDiscordRole {
  id              String        @id @default(uuid()) @db.Uuid
  discordRoleId   String?       @map("discord_role_id")
  Group           Group         @relation(fields: [groupId], references: [id], onDelete: Cascade)
  groupId         String        @unique @map("group_id") @db.Uuid
  discordServer   DiscordServer @relation(fields: [discordServerId], references: [id], onDelete: Cascade)
  discordServerId String        @map("discord_server_id") @db.Uuid
  color           Int?
  name            String
  icon            String?
  unicodeEmoji    String?       @map("unicode_emoji")
  memberCount     Int?          @map("member_count")
  createdAt       DateTime      @default(now()) @map("created_at")
  updatedAt       DateTime      @default(now()) @updatedAt @map("updated_at")

  @@unique([discordServerId, discordRoleId])
  @@unique([discordServerId, name])
  @@map("discord_role_groups")
}

model GroupTelegramChat {
  id                  String   @id @default(uuid()) @db.Uuid
  groupId             String   @unique @map("group_id") @db.Uuid
  Group               Group    @relation(fields: [groupId], references: [id], onDelete: Cascade)
  name                String
  chatId              BigInt   @unique @map("chat_id")
  // thread where group wants to receive notifications. if null, chat will receive messages in "general"
  messageThreadId     BigInt?  @map("message_thread_id")
  adminTelegramUserId BigInt   @map("admin_telegram_user_id")
  createdAt           DateTime @default(now()) @map("created_at")

  @@map("groups_telegram_chat")
}

enum NftTypes {
  ERC721
  ERC1155
}

enum Blockchain {
  Ethereum
  Arbitrum
  Optimism
  Matic
  Base
}

model GroupCustom {
  id                   String  @id @default(uuid()) @db.Uuid
  name                 String
  description          String?
  groupId              String  @unique @map("group_id") @db.Uuid
  entitySetId          String  @map("entity_set_id") @db.Uuid
  notificationEntityId String? @map("notification_entity_id") @db.Uuid

  NotificationEntity Entity?   @relation(fields: [notificationEntityId], references: [id], onDelete: Cascade)
  MemberEntitySet    EntitySet @relation(fields: [entitySetId], references: [id], onDelete: Cascade)
  group              Group     @relation(fields: [groupId], references: [id], onDelete: Cascade)

  @@map("groups_custom")
}

model GroupNft {
  id           String  @id @default(uuid()) @db.Uuid
  name         String
  icon         String?
  groupId      String  @unique @map("group_id") @db.Uuid
  collectionId String  @map("collection_id") @db.Uuid
  // null tokenId means that this group applies to all tokens in that collection
  tokenId      String? @map("token_id")

  Group         Group         @relation(fields: [groupId], references: [id], onDelete: Cascade)
  NftCollection NftCollection @relation(fields: [collectionId], references: [id], onDelete: Cascade)

  @@unique([collectionId, tokenId])
  @@map("groups_nft")
}

model NftCollection {
  id       String     @id @default(uuid()) @db.Uuid
  name     String?
  icon     String?
  chain    Blockchain
  type     NftTypes
  address  String
  GroupNft GroupNft[]

  @@unique([chain, address])
  @@map("nft_collections")
}

model DiscordServer {
  id               String             @id @default(uuid()) @db.Uuid
  discordServerId  String             @unique @map("discord_server_id")
  name             String
  icon             String?
  banner           String?
  createdAt        DateTime           @default(now()) @map("created_at")
  updatedAt        DateTime           @default(now()) @updatedAt @map("updated_at")
  GroupDiscordRole GroupDiscordRole[]

  @@map("discord_servers")
}

enum FlowType {
  Custom
  Evolve
  EvolveGroup
  GroupWatchFlow
}

model Flow {
  id              String   @id @default(uuid()) @db.Uuid
  groupId         String?  @map("custom_group_id") @db.Uuid
  type            FlowType
  reusable        Boolean
  creatorEntityId String   @map("creator_entity_id") @db.Uuid

  currentFlowVersionId String? @unique @map("current_flow_version_id") @db.Uuid

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @default(now()) @updatedAt @map("updated_at")

  CreatorEntity               Entity               @relation(fields: [creatorEntityId], references: [id], onDelete: Cascade)
  OwnerGroup                  Group?               @relation(fields: [groupId], references: [id], onDelete: Cascade)
  CurrentFlowVersion          FlowVersion?         @relation("FlowToCurrentFlowVersion", fields: [currentFlowVersionId], references: [id])
  FlowVersions                FlowVersion[]        @relation("FlowToAllFlowVersions")
  EvolveRightsForFlowVersions FlowVersion[]        @relation("EvolveFlowToFlowVersions")
  GroupsWatchedFlows          GroupsWatchedFlows[]
  EntityWatchedFlows          EntityWatchedFlows[]

  @@map("flows")
}

model FlowVersion {
  id                       String       @id @default(uuid()) @db.Uuid
  name                     String
  // whether the flow version is live
  // TODO: There should only be one active flow version per flow. In the future, we should enforce this constraint in the db
  active                   Boolean
  flowId                   String       @map("flow_id") @db.Uuid
  Flow                     Flow         @relation("FlowToAllFlowVersions", fields: [flowId], references: [id], onDelete: Cascade)
  // the evolve flow id gives evolve flow edit rights over all steps in the flow
  evolveFlowId             String?      @map("evolve_flow_id") @db.Uuid
  EvolveFlow               Flow?        @relation("EvolveFlowToFlowVersions", fields: [evolveFlowId], references: [id], onDelete: Cascade)
  // this field is used for the evolve process so that a flow version and it's corresponding evolve flow can be evolved at the same time
  draftEvolveFlowVersionId String?      @map("draft_evolve_flow_version_id") @db.Uuid
  DraftEvolveFlowVersion   FlowVersion? @relation("DraftEvolveFlowVersion", fields: [draftEvolveFlowVersionId], references: [id], onDelete: SetNull)

  createdAt   DateTime  @default(now()) @map("created_at")
  // when the flow version moved from draft to published
  publishedAt DateTime? @map("published_at")

  FlowForCurrentVersion Flow? @relation("FlowToCurrentFlowVersion")

  TriggerFieldSet                              FieldSet?
  TriggerPermissions                           Permission?
  Steps                                        Step[]
  Request                                      Request[]     @relation("FlowVersion")
  // The request that proposes this flow version as the next version
  EvolutionRequest                             Request?      @relation("ProposedFlowVersionEvolution")
  FlowVersionsReferencingThisEvolveFlowVersion FlowVersion[] @relation("DraftEvolveFlowVersion")

  @@map("flow_versions")
}

// Note: In this current model, steps are tied to a given workflow,
// If in the future, we wanted to allow steps to be reusable by different flows while preserving flow data immutability,
// we'd need to create a steps_versions_model and flows_versions_steps model.
// Too much complexity for v1
model Step {
  id            String   @id @default(uuid()) @db.Uuid
  flowVersionId String   @map("flow_version_id") @db.Uuid
  index         Int
  createdAt     DateTime @default(now()) @map("created_at")

  FlowVersion      FlowVersion      @relation(fields: [flowVersionId], references: [id], onDelete: Cascade)
  ResponseConfig   ResponseConfig?
  ResponseFieldSet FieldSet?
  ResultConfigSet  ResultConfigSet?
  ActionConfigSet  ActionConfigSet?
  RequestStep      RequestStep[]

  @@map("steps")
}

model ResponseConfig {
  id                     String   @id @default(uuid()) @db.Uuid
  stepId                 String   @unique @map("step_id") @db.Uuid
  Step                   Step     @relation(fields: [stepId], references: [id], onDelete: Cascade)
  createdAt              DateTime @default(now()) @map("created_at")
  updatedAt              DateTime @default(now()) @updatedAt @map("updated_at")
  expirationSeconds      Int      @default(0) @map("request_expiration_seconds")
  // can be ended manually be the creator of the request
  canBeManuallyEnded     Boolean  @default(false) @map("can_be_manually_ended")
  allowMultipleResponses Boolean  @default(false) @map("allow_multiple_responses")
  // Minimum answers for a result to be created
  minResponses           Int      @default(1) @map("min_responses")

  ResponsePermissions Permission?

  @@map("response_configs")
}

model Permission {
  id String @id @default(uuid()) @db.Uuid

  responseConfigId String?         @unique @map("response_config_id") @db.Uuid
  ResponseConfig   ResponseConfig? @relation(fields: [responseConfigId], references: [id], onDelete: Cascade)
  flowVersionId    String?         @unique @map("flow_version_id") @db.Uuid
  FlowVersion      FlowVersion?    @relation(fields: [flowVersionId], references: [id], onDelete: Cascade)
  anyone           Boolean         @default(false)
  entitySetId      String?         @unique @map("entity_set_id") @db.Uuid
  EntitySet        EntitySet?      @relation(fields: [entitySetId], references: [id], onDelete: Cascade)
  createdAt        DateTime        @default(now()) @map("created_at")

  @@map("permissions")
}

model EntitySet {
  id                String              @id @default(uuid()) @db.Uuid
  createdAt         DateTime            @default(now()) @map("created_at")
  EntitySetEntities EntitySetEntities[]
  GroupCustom       GroupCustom[]
  Permission        Permission?

  @@map("entity_sets")
}

model EntitySetEntities {
  entitySetId String @map("entity_set_id") @db.Uuid
  entityId    String @map("entity_id") @db.Uuid

  EntitySet EntitySet @relation(fields: [entitySetId], references: [id], onDelete: Cascade)
  Entity    Entity    @relation(fields: [entityId], references: [id], onDelete: Cascade)

  @@unique([entityId, entitySetId])
  @@map("entity_set_entities")
}

// Entities are anything that can be assigned a role. 
// For now, that's goups and identities
model Entity {
  id        String   @id @default(uuid()) @db.Uuid
  createdAt DateTime @default(now()) @map("created_at")

  Group                   Group?
  Identity                Identity?
  User                    User?
  EntitySetEntities       EntitySetEntities[]
  NotifiesForCustomGroups GroupCustom[]
  Responses               Response[]
  EntityWatchedFlows      EntityWatchedFlows[]
  EntityWatchedGroups     EntityWatchedGroups[]
  Flow                    Flow[]
  Request                 Request[]
  CreatedGroups           Group[]               @relation("Creator")

  @@map("entities")
}

// List of fields for use in request or response
model FieldSet {
  id            String       @id @default(uuid()) @db.Uuid
  stepId        String?      @unique @map("entity_id") @db.Uuid
  flowVersionId String?      @unique @map("flow_version_id") @db.Uuid
  createdAt     DateTime     @default(now()) @map("created_at")
  // this means that all fields in the field set cannot be changed via flow evolution
  locked        Boolean      @default(false)
  FlowVersion   FlowVersion? @relation(fields: [flowVersionId], references: [id], onDelete: Cascade)
  Step          Step?        @relation(fields: [stepId], references: [id], onDelete: Cascade)
  Fields        Field[]

  @@map("field_sets")
}

enum FieldDataType {
  String
  Number
  Uri
  Date
  DateTime
  FlowVersionId
  EntityIds
  FlowIds
}

enum FieldType {
  Options
  FreeInput
}

enum SystemFieldType {
  EvolveFlowProposed
  EvolveFlowCurrent
  EvolveFlowDescription
  GroupName
  GroupDescription
  GroupMembers
  WatchFlow
  UnwatchFlow
}

// Describes a single ask for a users input (e.g. select an option)
model Field {
  id                String           @id @default(uuid()) @db.Uuid
  fieldSetId        String           @map("field_set_id") @db.Uuid
  index             Int
  type              FieldType
  name              String
  required          Boolean          @default(true)
  isInternal        Boolean          @default(false) @map("is_internal")
  systemType        SystemFieldType? @map("system_field_type")
  freeInputDataType FieldDataType?   @map("free_input_data_type")
  createdAt         DateTime         @default(now()) @map("created_at")

  Answers                 FieldAnswer[]
  ResultConfig            ResultConfig[]
  FieldSet                FieldSet                  @relation(fields: [fieldSetId], references: [id], onDelete: Cascade)
  RequestDefinedOptionSet RequestDefinedOptionSet[]
  TelegramMessages        TelegramMessages[]
  FieldOptionsConfig      FieldOptionsConfig?

  @@unique([index, fieldSetId])
  @@map("fields")
}

enum OptionSelectionType {
  Rank
  MultiSelect
  Select
}

// Describes how a set of options are created on a request 
model FieldOptionsConfig {
  id                     String              @id @default(uuid()) @db.Uuid
  fieldId                String              @unique @map("field_id") @db.Uuid
  Field                  Field               @relation(fields: [fieldId], references: [id], onDelete: Cascade)
  requestOptionsDataType FieldDataType?      @map("data_type")
  // Whether or not options are created by the requestor
  previousStepOptions    Boolean             @default(false) @map("previous_step_options")
  // Whether option is single or multi-select. Null means no maximum # of selections
  maxSelections          Int?                @map("max_selections")
  linkedResultOptions    String[]            @default([]) @map("linked_result_options")
  // type single select / multi-select / etc
  selectionType          OptionSelectionType @map("option_selection_type")
  createdAt              DateTime            @default(now()) @map("created_at")

  fieldOptionSetId    String?         @map("field_option_set_id") @db.Uuid
  PredefinedOptionSet FieldOptionSet? @relation(fields: [fieldOptionSetId], references: [id])

  @@map("field_options_configs")
}

model FieldOptionSet {
  id        String   @id @default(uuid()) @db.Uuid
  createdAt DateTime @default(now()) @map("created_at")

  FieldOptions            FieldOption[]
  RequestDefinedOptionSet RequestDefinedOptionSet[]
  FieldOptionsConfig      FieldOptionsConfig[]

  @@map("field_option_sets")
}

model FieldOption {
  id               String        @id @default(uuid()) @db.Uuid
  index            Int
  fieldOptionSetId String        @map("field_option_set_id") @db.Uuid
  dataType         FieldDataType @map("data_type")
  name             String
  createdAt        DateTime      @default(now()) @map("created_at")

  FieldOptionSet            FieldOptionSet          @relation(fields: [fieldOptionSetId], references: [id], onDelete: Cascade)
  AnswerOptionSelections    AnswerOptionSelection[]
  DefaultOptionForDecisions ResultConfigDecision[]
  ActionFilter              ActionConfigFilter[]
  ResultItems               ResultItems[]

  @@unique([index, fieldOptionSetId])
  @@map("field_options")
}

// An answer is either an array of free input responses or option selections for a given field
model FieldAnswer {
  id         String    @id @default(uuid()) @db.Uuid
  type       FieldType
  responseId String?   @map("response_id") @db.Uuid
  requestId  String?   @map("request_id") @db.Uuid
  fieldId    String    @map("field_id") @db.Uuid
  createdAt  DateTime  @default(now()) @map("created_at")

  Field                  Field                   @relation(fields: [fieldId], references: [id], onDelete: Cascade)
  Response               Response?               @relation(fields: [responseId], references: [id], onDelete: Cascade)
  Request                Request?                @relation(fields: [requestId], references: [id], onDelete: Cascade)
  AnswerOptionSelections AnswerOptionSelection[]
  AnswerFreeInput        AnswerFreeInput?

  @@map("answers")
}

model AnswerOptionSelection {
  id                String   @id @default(uuid()) @db.Uuid
  fieldAnswerId     String   @map("field_answer_id") @db.Uuid
  fieldOptionId     String   @map("field_option_id") @db.Uuid
  answerFreeInputId String?  @unique @map("answer_free_input_id") @db.Uuid
  // score used determining relative weight of option selections (e.g. ranking). higher weight = stronger preference 
  weight            Int      @default(1)
  createdAt         DateTime @default(now()) @map("created_at")

  FieldOption     FieldOption      @relation(fields: [fieldOptionId], references: [id], onDelete: Cascade)
  FieldAnswer     FieldAnswer      @relation(fields: [fieldAnswerId], references: [id], onDelete: Cascade)
  AnswerFreeInput AnswerFreeInput? @relation(fields: [answerFreeInputId], references: [id], onDelete: Cascade)

  @@map("answer_option_selections")
}

model AnswerFreeInput {
  id            String        @id @default(uuid()) @db.Uuid
  dataType      FieldDataType @map("data_type")
  fieldAnswerId String        @unique @map("field_answer_id") @db.Uuid
  value         String
  createdAt     DateTime      @default(now()) @map("created_at")

  FieldAnswer           FieldAnswer            @relation(fields: [fieldAnswerId], references: [id], onDelete: Cascade)
  AnswerOptionSelection AnswerOptionSelection?

  @@map("answer_free_inputs")
}

// List of fields for use in request or response
model ResultConfigSet {
  id            String         @id @default(uuid()) @db.Uuid
  createdAt     DateTime       @default(now()) @map("created_at")
  stepId        String         @unique @map("step_id") @db.Uuid
  Step          Step           @relation(fields: [stepId], references: [id], onDelete: Cascade)
  ResultConfigs ResultConfig[]

  @@map("result_config_sets")
}

enum ResultType {
  RawAnswers
  Decision
  Ranking
  LlmSummary
}

// Describes how and when a final result is created
model ResultConfig {
  id                String          @id @default(uuid()) @db.Uuid
  resultConfigSetId String          @map("result_config_set_id") @db.Uuid
  ResultConfigSet   ResultConfigSet @relation(fields: [resultConfigSetId], references: [id], onDelete: Cascade)
  fieldId           String          @map("field_id") @db.Uuid
  Field             Field           @relation(fields: [fieldId], references: [id], onDelete: Cascade)
  index             Int
  resultType        ResultType      @map("result_type")
  // whether output will be a single item or a list of items
  createdAt         DateTime        @default(now()) @map("created_at")

  ResultConfigDecision ResultConfigDecision?
  ResultConfigRank     ResultConfigRank?
  ResultConfigLlm      ResultConfigLlm?
  ResultGroups         ResultGroup[]
  ActionConfigFilter   ActionConfigFilter[]

  @@unique([index, resultConfigSetId])
  @@map("result_configs")
}

enum DecisionType {
  NumberThreshold
  PercentageThreshold
  WeightedAverage
  Ai
}

model ResultConfigDecision {
  id              String       @id @default(uuid()) @db.Uuid
  resultConfigId  String       @unique @map("result_config_id") @db.Uuid
  ResultConfig    ResultConfig @relation(fields: [resultConfigId], references: [id], onDelete: Cascade)
  type            DecisionType
  defaultOptionId String?      @map("default_option_id") @db.Uuid
  // Threshold is interpreted as count when type is "threshold" and as a percentage when type is "Percentage"
  threshold       Int?         @map("threshold")
  criteria        String?
  createdAt       DateTime     @default(now()) @map("created_at")

  DefaultFieldOption FieldOption? @relation(fields: [defaultOptionId], references: [id], onDelete: Cascade)

  @@map("result_config_decisions")
}

model ResultConfigRank {
  id                  String       @id @default(uuid()) @db.Uuid
  resultConfigId      String       @unique @map("result_config_id") @db.Uuid
  ResultConfig        ResultConfig @relation(fields: [resultConfigId], references: [id], onDelete: Cascade)
  // null means include all options
  numOptionsToInclude Int?         @map("num_options")
  createdAt           DateTime     @default(now()) @map("created_at")

  @@map("result_config_rankings")
}

model ResultConfigLlm {
  id             String       @id @default(uuid()) @db.Uuid
  resultConfigId String       @unique @map("result_config_id") @db.Uuid
  ResultConfig   ResultConfig @relation(fields: [resultConfigId], references: [id], onDelete: Cascade)
  isList         Boolean      @default(false) @map("is_list")
  prompt         String
  createdAt      DateTime     @default(now()) @map("created_at")

  @@map("result_config_llms")
}

model ActionConfigSet {
  id        String   @id @default(uuid()) @db.Uuid
  stepId    String   @unique @map("step_id") @db.Uuid
  Step      Step     @relation(fields: [stepId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now()) @map("created_at")

  ActionConfigs ActionConfig[]

  @@map("action_config_sets")
}

enum ActionType {
  CallWebhook
  TriggerStep
  EvolveFlow
  EvolveGroup
  GroupWatchFlow

  @@map("ActionType")
}

model ActionConfig {
  id                String     @id @default(uuid()) @db.Uuid
  actionConfigSetId String     @map("action_config_set_id") @db.Uuid
  index             Int
  type              ActionType
  // locked here means that the ActionType is locked. Other parts of the action can still be changed
  locked            Boolean    @default(false)
  createdAt         DateTime   @default(now()) @map("created_at")

  ActionConfigSet     ActionConfigSet      @relation(fields: [actionConfigSetId], references: [id], onDelete: Cascade)
  ActionConfigWebhook ActionConfigWebhook?
  ActionConfigFilter  ActionConfigFilter?
  ActionExecutions    Action[]

  @@unique([index, actionConfigSetId])
  @@map("action_configs")
}

model ActionConfigFilter {
  id             String   @id @default(uuid()) @db.Uuid
  actionConfigId String   @unique @map("action_config_id") @db.Uuid
  resultConfigId String   @map("result_config_id") @db.Uuid
  optionId       String   @map("filter_option_id") @db.Uuid
  createdAt      DateTime @default(now()) @map("created_at")

  ActionConfig ActionConfig @relation(fields: [actionConfigId], references: [id], onDelete: Cascade)
  ResultConfig ResultConfig @relation(fields: [resultConfigId], references: [id], onDelete: Cascade)
  FieldOption  FieldOption  @relation(fields: [optionId], references: [id], onDelete: Cascade)

  @@map("action_filters")
}

model ActionConfigWebhook {
  id             String   @id @default(uuid()) @db.Uuid
  actionConfigId String   @unique @map("action_config_id") @db.Uuid
  name           String
  uri            String
  uriPreview     String   @map("uri_preview")
  createdAt      DateTime @default(now()) @map("created_at")

  ActionConfig ActionConfig @relation(fields: [actionConfigId], references: [id], onDelete: Cascade)

  @@map("webhooks")
}

// Set up for multiple actions to be run in a single step even though there is currently only one action per step
model Action {
  id              String    @id @default(uuid()) @db.Uuid
  actionConfigId  String    @map("action_config_id") @db.Uuid
  requestStepId   String    @map("request_step_id") @db.Uuid
  complete        Boolean   @default(false)
  lastAttemptedAt DateTime  @default(now()) @map("last_attempted_at")
  retryAttempts   Int       @default(0) @map("retry_attempts")
  nextRetryAt     DateTime? @map("next_retry_at")
  createdAt       DateTime  @default(now()) @map("created_at")
  updatedAt       DateTime  @default(now()) @updatedAt @map("updated_at")

  ActionConfig ActionConfig @relation(fields: [actionConfigId], references: [id], onDelete: Cascade)
  RequestStep  RequestStep  @relation(fields: [requestStepId], references: [id], onDelete: Cascade)

  @@unique([actionConfigId, requestStepId])
  @@map("action_executions")
}

model Request {
  id                           String       @id @default(uuid()) @db.Uuid
  creatorEntityId              String       @map("creator_entity_id") @db.Uuid
  name                         String
  final                        Boolean      @default(false)
  CreatorEntity                Entity       @relation(fields: [creatorEntityId], references: [id], onDelete: Cascade)
  flowVersionId                String       @map("flow_version_id") @db.Uuid
  FlowVersion                  FlowVersion  @relation("FlowVersion", fields: [flowVersionId], references: [id], onDelete: Cascade)
  currentRequestStepId         String?      @unique @map("current_request_step_id") @db.Uuid
  CurrentRequestStep           RequestStep? @relation("CurrentRequestStep", fields: [currentRequestStepId], references: [id], onDelete: Cascade)
  // if a request is an "evolve" request, this field will include the proposed flow version id
  proposedFlowVersionId        String?      @unique @map("proposed_flow_version_id") @db.Uuid
  ProposedFlowVersionEvolution FlowVersion? @relation("ProposedFlowVersionEvolution", fields: [proposedFlowVersionId], references: [id], onDelete: Cascade)
  createdAt                    DateTime     @default(now()) @map("created_at")
  updatedAt                    DateTime     @default(now()) @updatedAt @map("updated_at")

  // For when the options are request are created by the requestor or the previous step
  RequestSteps             RequestStep[]
  TriggerFieldAnswers      FieldAnswer[]
  RequestDefinedOptionSets RequestDefinedOptionSet[]

  @@map("requests")
}

model RequestStep {
  id             String   @id @default(uuid()) @db.Uuid
  requestId      String   @map("request_id") @db.Uuid
  stepId         String   @map("step_id") @db.Uuid
  responseFinal  Boolean  @default(false) @map("response_final")
  // 'final' results doesn't necessarily mean there are results, but rather that the step will no longer attempt to create results
  resultsFinal   Boolean  @default(false) @map("results_final")
  // 'final' action doesn't necessarily mean an action was successfully performed, but rather that the step will no longer attempt to run the action
  actionsFinal   Boolean  @default(false) @map("actions_final")
  // request Step is 'final' only if responseFinal, resultsFinal, and actionsFinal are all true
  final          Boolean  @default(false)
  expirationDate DateTime @map("expiration_date")
  createdAt      DateTime @default(now()) @map("created_at")
  updatedAt      DateTime @default(now()) @updatedAt @map("updated_at")

  Request           Request            @relation(fields: [requestId], references: [id], onDelete: Cascade)
  Step              Step               @relation(fields: [stepId], references: [id], onDelete: Cascade)
  CurrentStepParent Request?           @relation("CurrentRequestStep")
  ResultGroups      ResultGroup[]
  Responses         Response[]
  Actions           Action[]
  TelegramMessages  TelegramMessages[]

  @@unique([stepId, requestId])
  @@map("request_steps")
}

model RequestDefinedOptionSet {
  id               String         @id @default(uuid()) @db.Uuid
  requestId        String         @map("request_step_id") @db.Uuid
  Request          Request        @relation(fields: [requestId], references: [id], onDelete: Cascade)
  fieldId          String         @map("field_id") @db.Uuid
  Field            Field          @relation(fields: [fieldId], references: [id], onDelete: Cascade)
  fieldOptionSetId String         @map("field_option_set_id") @db.Uuid
  FieldOptionSet   FieldOptionSet @relation(fields: [fieldOptionSetId], references: [id])

  @@map("request_defined_option_sets")
}

model Response {
  id              String   @id @default(uuid()) @db.Uuid
  requestStepId   String   @map("request_step_id") @db.Uuid
  // entity that created the response
  creatorEntityId String   @map("entity_id") @db.Uuid
  createdAt       DateTime @default(now()) @map("created_at")

  RequestStep   RequestStep   @relation(fields: [requestStepId], references: [id], onDelete: Cascade)
  Answers       FieldAnswer[]
  CreatorEntity Entity        @relation(fields: [creatorEntityId], references: [id], onDelete: Cascade)

  @@map("responses")
}

// there is a single results record for a given request step + results Config 
// so if a step has two result Configs, there will be two Results every time that Result rows
// A given result is associated with one or more result items (e.g. a single decision vs a prioritized list of options)
// The result model is an attempt of a result creation, but there may not actually be results in this attempt (e.g. the minimum vote threshold isn't hit for a decision)
model ResultGroup {
  id             String       @id @default(uuid()) @db.Uuid
  requestStepId  String       @map("request_step_id") @db.Uuid
  resultConfigId String       @map("result_config_id") @db.Uuid
  // whether a given result has finished completing
  complete       Boolean      @default(false)
  // if result hasn't finished completing, how many times has it been retried and when will it be retried next
  retryAttempts  Int          @default(0) @map("retry_attempts")
  nextRetryAt    DateTime?    @map("next_retry_at")
  createdAt      DateTime     @default(now()) @map("created_at")
  updatedAt      DateTime     @default(now()) @updatedAt @map("updated_at")
  Result         Result[]
  RequestStep    RequestStep  @relation(fields: [requestStepId], references: [id], onDelete: Cascade)
  ResultConfig   ResultConfig @relation(fields: [resultConfigId], references: [id], onDelete: Cascade)

  @@unique([requestStepId, resultConfigId])
  @@map("result_groups")
}

model Result {
  id            String     @id @default(uuid()) @db.Uuid
  resultGroupId String     @map("result_group_id") @db.Uuid
  type          ResultType @map("result_type")
  name          String

  // 0 index is primary result
  index Int

  ResultGroup ResultGroup   @relation(fields: [resultGroupId], references: [id], onDelete: Cascade)
  ResultItems ResultItems[]

  @@map("results")
}

model ResultItems {
  id            String        @id @default(uuid()) @db.Uuid
  value         String
  dataType      FieldDataType @map("data_type")
  fieldOptionId String?       @map("field_option_id") @db.Uuid
  resultId      String        @db.Uuid
  // used for ranking results. higher weight = stronger preference
  weight        Float         @default(1)
  createdAt     DateTime      @default(now()) @map("created_at")

  Result Result       @relation(fields: [resultId], references: [id], onDelete: Cascade)
  Option FieldOption? @relation(fields: [fieldOptionId], references: [id], onDelete: Cascade)

  @@map("result_items")
}

model EntityWatchedGroups {
  entityId String  @map("entity_id") @db.Uuid
  groupId  String  @map("group_id") @db.Uuid
  watched  Boolean

  Entity Entity @relation(fields: [entityId], references: [id], onDelete: Cascade)
  Group  Group  @relation(fields: [groupId], references: [id], onDelete: Cascade)

  @@unique([entityId, groupId])
  @@map("entity_watched_groups")
}

model EntityWatchedFlows {
  entityId String  @map("entity_id") @db.Uuid
  flowId   String  @map("flow_id") @db.Uuid
  watched  Boolean

  Flow   Flow   @relation(fields: [flowId], references: [id], onDelete: Cascade)
  Entity Entity @relation(fields: [entityId], references: [id], onDelete: Cascade)

  @@unique([entityId, flowId])
  @@map("entity_watched_flows")
}

model GroupsWatchedFlows {
  flowId  String  @map("flow_id") @db.Uuid
  groupId String  @map("group_id") @db.Uuid
  watched Boolean

  Flow  Flow  @relation(fields: [flowId], references: [id], onDelete: Cascade)
  Group Group @relation(fields: [groupId], references: [id], onDelete: Cascade)

  @@unique([flowId, groupId])
  @@map("groups_watched_flows")
}

model TelegramMessages {
  id            String  @id @default(uuid()) @db.Uuid
  chatId        BigInt  @map("chat_id")
  messageId     BigInt  @unique @map("message_id")
  pollId        BigInt? @unique @map("poll_id")
  requestStepId String  @map("request_step_id") @db.Uuid
  fieldId       String? @map("field_id") @db.Uuid

  createdAt DateTime @default(now()) @map("created_at")

  RequestStep RequestStep @relation(fields: [requestStepId], references: [id], onDelete: Cascade)
  Field       Field?      @relation(fields: [fieldId], references: [id], onDelete: Cascade)

  @@map("telegram_messages")
}

// model Notifications {
//   id String @id @default(uuid()) @db.Uuid

//   @@map("notifications")
// }
