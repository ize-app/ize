generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["fullTextSearch"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        String   @id @default(uuid()) @db.Uuid
  stytchId  String   @unique @map("stytch_id")
  entityId  String   @unique @map("entity_id") @db.Uuid
  name      String   @default("")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @default(now()) @updatedAt @map("updated_at")

  Group      Group[]
  Identities Identity[]
  Oauths     Oauths[]
  Entity     Entity     @relation(fields: [entityId], references: [id], onDelete: Cascade)

  @@map("users")
}

model Identity {
  id        String   @id @default(uuid()) @db.Uuid
  userId    String?  @map("user_id") @db.Uuid
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @default(now()) @updatedAt @map("updated_at")
  // TODO make this field required
  entityId  String   @unique @map("entity_id") @db.Uuid

  User               User?               @relation(fields: [userId], references: [id], onDelete: Cascade)
  IdentityEmail      IdentityEmail?
  IdentityBlockchain IdentityBlockchain?
  IdentityDiscord    IdentityDiscord?
  IdentitiesGroups   IdentityGroup[]
  Entity             Entity              @relation(fields: [entityId], references: [id], onDelete: Cascade)
  IdentityTelegram   IdentityTelegram?

  @@map("identities")
}

model IdentityEmail {
  id         String   @id @default(uuid()) @db.Uuid
  identityId String   @unique @map("identity_id") @db.Uuid
  email      String   @unique
  icon       String?
  createdAt  DateTime @default(now()) @map("created_at")
  updatedAt  DateTime @default(now()) @updatedAt @map("updated_at")

  Identity Identity @relation(fields: [identityId], references: [id], onDelete: Cascade)

  @@map("identities_email")
}

model IdentityBlockchain {
  id         String   @id @default(uuid()) @db.Uuid
  identityId String   @unique @map("identity_id") @db.Uuid
  address    String   @unique
  ens        String?
  createdAt  DateTime @default(now()) @map("created_at")
  updatedAt  DateTime @default(now()) @updatedAt @map("updated_at")

  Identity Identity @relation(fields: [identityId], references: [id], onDelete: Cascade)

  @@map("identities_blockchain")
}

model IdentityDiscord {
  id            String   @id @default(uuid()) @db.Uuid
  identityId    String   @unique @map("identity_id") @db.Uuid
  discordUserId String   @map("discord_user_id")
  username      String
  discriminator String
  avatar        String?
  createdAt     DateTime @default(now()) @map("created_at")
  updatedAt     DateTime @default(now()) @updatedAt @map("updated_at")

  Identity Identity @relation(fields: [identityId], references: [id], onDelete: Cascade)

  @@map("identities_discord")
}

model IdentityTelegram {
  id             String  @id @default(uuid()) @db.Uuid
  identityId     String  @unique @map("identity_id") @db.Uuid
  telegramUserId BigInt  @unique @map("telegram_user_id")
  username       String?
  photoUrl       String? @map("photo_url")
  firstName      String  @map("first_name")
  lastName       String? @map("last_name")

  Identity Identity @relation(fields: [identityId], references: [id], onDelete: Cascade)

  @@map("identities_telegram")
}

model IdentityGroup {
  identityId String   @map("identity_id") @db.Uuid
  groupId    String   @map("group_id") @db.Uuid
  active     Boolean
  createdAt  DateTime @default(now()) @map("created_at")
  updatedAt  DateTime @default(now()) @updatedAt @map("updated_at")

  Identity Identity @relation(fields: [identityId], references: [id], onDelete: Cascade)
  Group    Group    @relation(fields: [groupId], references: [id], onDelete: Cascade)

  @@unique([identityId, groupId])
  @@map("identities_groups")
}

enum OauthTypes {
  Discord
  Google
}

model Oauths {
  userId       String     @map("user_id") @db.Uuid
  type         OauthTypes
  accessToken  String     @map("access_token")
  refreshToken String     @map("refresh_token")
  idToken      String?    @map("id_token")
  scopes       Json[]
  expiresAt    DateTime?  @map("expires_at")
  createdAt    DateTime   @default(now()) @map("created_at")
  updatedAt    DateTime   @default(now()) @updatedAt @map("updated_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id(name: "id", [userId, type])
  @@map("oauths")
}

enum GroupType {
  DiscordRoleGroup
  GroupNft
  GroupTelegram
  GroupCustom
}

model Group {
  id                  String                @id @default(uuid()) @db.Uuid
  creator             User?                 @relation(fields: [creatorId], references: [id])
  creatorId           String?               @map("creator_id") @db.Uuid
  entityId            String                @unique @map("entity_id") @db.Uuid
  createdAt           DateTime              @default(now()) @map("created_at")
  updatedAt           DateTime              @default(now()) @updatedAt @map("updated_at")
  activeAt            DateTime?
  deactivatedat       DateTime?
  type                GroupType
  Entity              Entity                @relation(fields: [entityId], references: [id], onDelete: Cascade)
  GroupDiscordRole    GroupDiscordRole?
  GroupNft            GroupNft?
  IdentitiesGroups    IdentityGroup[]
  GroupCustom         GroupCustom?
  EntityWatchedGroups EntityWatchedGroups[]
  OwnedFlows          Flow[]
  GroupsWatchedFlows  GroupsWatchedFlows[]
  GroupTelegramChat   GroupTelegramChat?

  @@map("groups")
}

model GroupDiscordRole {
  id              String        @id @default(uuid()) @db.Uuid
  discordRoleId   String?       @map("discord_role_id")
  Group           Group         @relation(fields: [groupId], references: [id], onDelete: Cascade)
  groupId         String        @unique @map("group_id") @db.Uuid
  discordServer   DiscordServer @relation(fields: [discordServerId], references: [id], onDelete: Cascade)
  discordServerId String        @map("discord_server_id") @db.Uuid
  color           Int?
  name            String
  icon            String?
  unicodeEmoji    String?       @map("unicode_emoji")
  memberCount     Int?          @map("member_count")
  createdAt       DateTime      @default(now()) @map("created_at")
  updatedAt       DateTime      @default(now()) @updatedAt @map("updated_at")

  @@unique([discordServerId, discordRoleId])
  @@unique([discordServerId, name])
  @@map("discord_role_groups")
}

model GroupTelegramChat {
  id                  String   @id @default(uuid()) @db.Uuid
  Group               Group    @relation(fields: [groupId], references: [id], onDelete: Cascade)
  name                String
  groupId             String   @unique @map("group_id") @db.Uuid
  chatId              BigInt   @unique @map("chat_id")
  // thread where group wants to receive notifications. if null, chat will receive messages in "general"
  messageThreadId     BigInt?  @map("message_thread_id")
  adminTelegramUserId BigInt   @map("admin_telegram_user_id")
  createdAt           DateTime @default(now()) @map("created_at")

  @@map("groups_telegram_chat")
}

enum NftTypes {
  ERC721
  ERC1155
}

enum Blockchain {
  Ethereum
  Arbitrum
  Optimism
  Matic
  Base
}

model GroupCustom {
  id                   String  @id @default(uuid()) @db.Uuid
  name                 String
  description          String?
  groupId              String  @unique @map("group_id") @db.Uuid
  entitySetId          String  @map("entity_set_id") @db.Uuid
  notificationEntityId String? @map("notification_entity_id") @db.Uuid

  NotificationEntity Entity?   @relation(fields: [notificationEntityId], references: [id], onDelete: Cascade)
  MemberEntitySet    EntitySet @relation(fields: [entitySetId], references: [id], onDelete: Cascade)
  group              Group     @relation(fields: [groupId], references: [id], onDelete: Cascade)

  @@map("groups_custom")
}

model GroupNft {
  id           String  @id @default(uuid()) @db.Uuid
  name         String
  icon         String?
  groupId      String  @unique @map("group_id") @db.Uuid
  collectionId String  @map("collection_id") @db.Uuid
  // null tokenId means that this group applies to all tokens in that collection
  tokenId      String? @map("token_id")

  Group         Group         @relation(fields: [groupId], references: [id], onDelete: Cascade)
  NftCollection NftCollection @relation(fields: [collectionId], references: [id], onDelete: Cascade)

  @@unique([collectionId, tokenId])
  @@map("groups_nft")
}

model NftCollection {
  id       String     @id @default(uuid()) @db.Uuid
  name     String?
  icon     String?
  chain    Blockchain
  type     NftTypes
  address  String
  GroupNft GroupNft[]

  @@unique([chain, address])
  @@map("nft_collections")
}

model DiscordServer {
  id               String             @id @default(uuid()) @db.Uuid
  discordServerId  String             @unique @map("discord_server_id")
  name             String
  icon             String?
  banner           String?
  createdAt        DateTime           @default(now()) @map("created_at")
  updatedAt        DateTime           @default(now()) @updatedAt @map("updated_at")
  GroupDiscordRole GroupDiscordRole[]

  @@map("discord_servers")
}

enum FlowType {
  Custom
  Evolve
  EvolveGroup
  GroupWatchFlow
}

model Flow {
  id              String   @id @default(uuid()) @db.Uuid
  groupId         String?  @map("custom_group_id") @db.Uuid
  type            FlowType
  reusable        Boolean
  creatorEntityId String   @map("creator_entity_id") @db.Uuid

  currentFlowVersionId String? @unique @map("current_flow_version_id") @db.Uuid

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @default(now()) @updatedAt @map("updated_at")

  CreatorEntity               Entity               @relation(fields: [creatorEntityId], references: [id], onDelete: Cascade)
  OwnerGroup                  Group?               @relation(fields: [groupId], references: [id], onDelete: Cascade)
  CurrentFlowVersion          FlowVersion?         @relation("FlowToCurrentFlowVersion", fields: [currentFlowVersionId], references: [id], onDelete: Cascade)
  FlowVersions                FlowVersion[]        @relation("FlowToAllFlowVersions")
  EvolveRightsForFlowVersions FlowVersion[]        @relation("EvolveFlowToFlowVersions")
  GroupsWatchedFlows          GroupsWatchedFlows[]
  EntityWatchedFlows          EntityWatchedFlows[]

  @@map("flows")
}

model FlowVersion {
  id           String  @id @default(uuid()) @db.Uuid
  name         String
  totalSteps   Int     @map("total_steps")
  flowId       String  @map("flow_id") @db.Uuid
  // the evolve flow id gives evolve flow edit rights over all steps in the flow
  evolveFlowId String? @map("evolve_flow_id") @db.Uuid

  triggerPermissionsId     String  @map("trigger_permissions_id") @db.Uuid
  triggerFieldSetId        String? @map("trigger_field_set_id") @db.Uuid
  // whether the flow version is live
  // TODO: There should only be one active flow version per flow. In the future, we should enforce this constraint in the db
  active                   Boolean
  // this field is used for the evolve process so that a flow version and it's corresponding evolve flow can be evolved at the same time
  draftEvolveFlowVersionId String? @map("draft_evolve_flow_version_id") @db.Uuid

  createdAt   DateTime  @default(now()) @map("created_at")
  // when the flow version moved from draft to published
  publishedAt DateTime? @map("published_at")

  FlowForCurrentVersion                        Flow?         @relation("FlowToCurrentFlowVersion")
  Flow                                         Flow          @relation("FlowToAllFlowVersions", fields: [flowId], references: [id], onDelete: Cascade)
  EvolveFlow                                   Flow?         @relation("EvolveFlowToFlowVersions", fields: [evolveFlowId], references: [id], onDelete: Cascade)
  TriggerPermissions                           Permission    @relation("TriggerPermissions", fields: [triggerPermissionsId], references: [id], onDelete: Cascade)
  TriggerFieldSet                              FieldSet?     @relation("TriggerFieldSet", fields: [triggerFieldSetId], references: [id], onDelete: Cascade)
  Steps                                        Step[]
  Request                                      Request[]     @relation("FlowVersion")
  // The request that proposes this flow version as the next version
  EvolutionRequest                             Request?      @relation("ProposedFlowVersionEvolution")
  // When a draft flow version is created, it's draft evolve flow version is also created and referenced here
  DraftEvolveFlowVersion                       FlowVersion?  @relation("DraftEvolveFlowVersion", fields: [draftEvolveFlowVersionId], references: [id], onDelete: Cascade)
  FlowVersionsReferencingThisEvolveFlowVersion FlowVersion[] @relation("DraftEvolveFlowVersion")

  @@map("flow_versions")
}

// Note: In this current model, steps are tied to a given workflow,
// If in the future, we wanted to allow steps to be reusable by different flows while preserving flow data immutability,
// we'd need to create a steps_versions_model and flows_versions_steps model.
// Too much complexity for v1
model Step {
  id            String @id @default(uuid()) @db.Uuid
  flowVersionId String @map("flow_version_id") @db.Uuid
  index         Int

  fieldSetId        String? @map("field_set_id") @db.Uuid
  responseConfigId  String? @map("response_config_id") @db.Uuid
  resultConfigSetId String? @map("result_config_set_id") @db.Uuid

  actionId  String?  @map("action_id") @db.Uuid
  createdAt DateTime @default(now()) @map("created_at")

  FlowVersion    FlowVersion     @relation(fields: [flowVersionId], references: [id], onDelete: Cascade)
  FieldSet       FieldSet?       @relation("StepFieldSet", fields: [fieldSetId], references: [id], onDelete: Cascade)
  ResponseConfig ResponseConfig? @relation(fields: [responseConfigId], references: [id], onDelete: Cascade)

  ResultConfigSet ResultConfigSet? @relation(fields: [resultConfigSetId], references: [id], onDelete: Cascade)

  Action      Action?       @relation("StepsWithAction", fields: [actionId], references: [id], onDelete: Cascade)
  RequestStep RequestStep[]

  @@map("steps")
}

model ResponseConfig {
  id                     String   @id @default(uuid()) @db.Uuid
  createdAt              DateTime @default(now()) @map("created_at")
  updatedAt              DateTime @default(now()) @updatedAt @map("updated_at")
  permissionsId          String   @map("permissions_id") @db.Uuid
  expirationSeconds      Int      @default(0) @map("request_expiration_seconds")
  // can be ended manually be the creator of the request
  canBeManuallyEnded     Boolean  @default(false) @map("can_be_manually_ended")
  allowMultipleResponses Boolean  @default(false) @map("allow_multiple_responses")

  ResponsePermissions Permission @relation("ResponsePermissions", fields: [permissionsId], references: [id], onDelete: Cascade)
  Step                Step[]

  @@map("response_configs")
}

model Permission {
  id String @id @default(uuid()) @db.Uuid

  entitySetId String?  @map("entity_set_id") @db.Uuid
  anyone      Boolean  @default(false)
  createdAt   DateTime @default(now()) @map("created_at")

  EntitySet                     EntitySet?       @relation(fields: [entitySetId], references: [id], onDelete: Cascade)
  TriggerPermissionFlowVersions FlowVersion[]    @relation("TriggerPermissions")
  ResponseConfigs               ResponseConfig[] @relation("ResponsePermissions")

  @@map("permissions")
}

model EntitySet {
  id                String              @id @default(uuid()) @db.Uuid
  Permissions       Permission[]
  createdAt         DateTime            @default(now()) @map("created_at")
  EntitySetEntities EntitySetEntities[]
  GroupCustom       GroupCustom[]

  @@map("entity_sets")
}

model EntitySetEntities {
  entitySetId String @map("entity_set_id") @db.Uuid
  entityId    String @map("entity_id") @db.Uuid

  EntitySet EntitySet @relation(fields: [entitySetId], references: [id], onDelete: Cascade)
  Entity    Entity    @relation(fields: [entityId], references: [id], onDelete: Cascade)

  @@unique([entityId, entitySetId])
  @@map("entity_set_entities")
}

// Entities are anything that can be assigned a role. 
// For now, that's goups and identities
model Entity {
  id        String   @id @default(uuid()) @db.Uuid
  createdAt DateTime @default(now()) @map("created_at")

  Group                   Group?
  Identity                Identity?
  User                    User?
  EntitySetEntities       EntitySetEntities[]
  NotifiesForCustomGroups GroupCustom[]
  Responses               Response[]
  EntityWatchedFlows      EntityWatchedFlows[]
  EntityWatchedGroups     EntityWatchedGroups[]
  Flow                    Flow[]
  Request                 Request[]

  @@map("entities")
}

// List of fields for use in request or response
model FieldSet {
  id                                   String            @id @default(uuid()) @db.Uuid
  createdAt                            DateTime          @default(now()) @map("created_at")
  // this means that all fields in the field set cannot be changed via flow evolution
  locked                               Boolean           @default(false)
  FlowVersionTriggersUsingThisFieldSet FlowVersion[]     @relation("TriggerFieldSet")
  StepsUsingThisFieldSet               Step[]            @relation("StepFieldSet")
  FieldSetFields                       FieldSetsFields[]

  @@map("field_sets")
}

// Purpose of this association table is so that there can be new sets of options without 
// needing to create new fields everytime there's a change to the group (since data is immutable in Ize)
model FieldSetsFields {
  fieldSetId String @map("field_set_id") @db.Uuid
  fieldId    String @map("field_id") @db.Uuid

  FieldSet FieldSet @relation(fields: [fieldSetId], references: [id], onDelete: Cascade)
  Field    Field    @relation(fields: [fieldId], references: [id], onDelete: Cascade)

  @@unique([fieldId, fieldSetId])
  @@map("field_sets_fields")
}

enum FieldDataType {
  String
  Number
  Uri
  Date
  DateTime
  FlowVersionId
  EntityIds
  FlowIds
  Webhook
}

enum FieldType {
  Options
  FreeInput
}

enum SystemFieldType {
  EvolveFlowProposed
  EvolveFlowCurrent
  EvolveFlowDescription
  GroupName
  GroupDescription
  GroupMembers
  WatchFlow
  UnwatchFlow
}

// Describes a single ask for a users input (e.g. select an option)
model Field {
  id                   String           @id @default(uuid()) @db.Uuid
  type                 FieldType
  name                 String
  required             Boolean          @default(true)
  isInternal           Boolean          @default(false) @map("is_internal")
  systemType           SystemFieldType? @map("system_field_type")
  freeInputDataType    FieldDataType?   @map("free_input_data_type")
  fieldOptionsConfigId String?          @map("field_options_config_id") @db.Uuid
  createdAt            DateTime         @default(now()) @map("created_at")

  FieldOptionsConfigs     FieldOptionsConfig?       @relation(fields: [fieldOptionsConfigId], references: [id], onDelete: Cascade)
  Answers                 FieldAnswer[]
  ResultConfig            ResultConfig[]
  FieldSetFields          FieldSetsFields[]
  RequestDefinedOptionSet RequestDefinedOptionSet[]
  TelegramMessages        TelegramMessages[]

  @@map("fields")
}

enum OptionSelectionType {
  Rank
  MultiSelect
  Select
}

// Describes how a set of options are created on a request 
model FieldOptionsConfig {
  id                     String              @id @default(uuid()) @db.Uuid
  fieldOptionSetId       String              @map("field_option_set_id") @db.Uuid
  requestOptionsDataType FieldDataType?      @map("data_type")
  // Whether or not options are created by the requestor
  previousStepOptions    Boolean             @default(false) @map("previous_step_options")
  // Whether option is single or multi-select. Null means no maximum # of selections
  maxSelections          Int?                @map("max_selections")
  linkedResultOptions    String[]            @default([]) @map("linked_result_options")
  // type single select / multi-select / etc
  selectionType          OptionSelectionType @map("option_selection_type")
  createdAt              DateTime            @default(now()) @map("created_at")

  Field          Field[]
  FieldOptionSet FieldOptionSet @relation(fields: [fieldOptionSetId], references: [id], onDelete: Cascade)

  @@map("field_options_configs")
}

model FieldOptionSet {
  id        String   @id @default(uuid()) @db.Uuid
  createdAt DateTime @default(now()) @map("created_at")

  FieldOptionsConfigs        FieldOptionsConfig[]
  FieldOptionSetFieldOptions FieldOptionSetsFieldOptions[]
  RequestDefinedOptionSet    RequestDefinedOptionSet[]

  @@map("field_option_sets")
}

// Purpose of this association table is so that there can be new sets of options without 
// needing to create new options everytime there's a change to the group (since data is immutable in Ize)
// This makes showing diffs between flow versions much eaiser
model FieldOptionSetsFieldOptions {
  fieldOptionSetId String @map("field_option_set_id") @db.Uuid
  fieldOptionId    String @map("field_option_id") @db.Uuid
  // The order that the option should be displayed
  index            Int

  FieldOptionSet FieldOptionSet @relation(fields: [fieldOptionSetId], references: [id], onDelete: Cascade)
  FieldOption    FieldOption    @relation(fields: [fieldOptionId], references: [id], onDelete: Cascade)

  @@unique([fieldOptionId, fieldOptionSetId])
  @@unique([index, fieldOptionSetId])
  @@map("field_option_set_field_options")
}

model FieldOption {
  id        String        @id @default(uuid()) @db.Uuid
  dataType  FieldDataType @map("data_type")
  name      String
  createdAt DateTime      @default(now()) @map("created_at")

  AnswerOptionSelections     AnswerOptionSelection[]
  FieldOptionSetFieldOptions FieldOptionSetsFieldOptions[]
  DefaultOptionForDecisions  ResultConfigDecision[]
  Action                     Action[]
  ResultItems                ResultItems[]

  @@map("field_options")
}

// An answer is either an array of free input responses or option selections for a given field
model FieldAnswer {
  id         String    @id @default(uuid()) @db.Uuid
  type       FieldType
  responseId String?   @map("response_id") @db.Uuid
  requestId  String?   @map("request_id") @db.Uuid
  fieldId    String    @map("field_id") @db.Uuid
  createdAt  DateTime  @default(now()) @map("created_at")

  Field                  Field                   @relation(fields: [fieldId], references: [id], onDelete: Cascade)
  Response               Response?               @relation(fields: [responseId], references: [id], onDelete: Cascade)
  Request                Request?                @relation(fields: [requestId], references: [id], onDelete: Cascade)
  AnswerOptionSelections AnswerOptionSelection[]
  AnswerFreeInput        AnswerFreeInput[]

  @@map("answers")
}

model AnswerOptionSelection {
  id                String   @id @default(uuid()) @db.Uuid
  fieldAnswerId     String   @map("field_answer_id") @db.Uuid
  fieldOptionId     String   @map("field_option_id") @db.Uuid
  answerFreeInputId String?  @unique @map("answer_free_input_id") @db.Uuid
  // score used determining relative weight of option selections (e.g. ranking). higher weight = stronger preference 
  weight            Int      @default(1)
  createdAt         DateTime @default(now()) @map("created_at")

  FieldOption     FieldOption      @relation(fields: [fieldOptionId], references: [id], onDelete: Cascade)
  FieldAnswer     FieldAnswer      @relation(fields: [fieldAnswerId], references: [id], onDelete: Cascade)
  AnswerFreeInput AnswerFreeInput? @relation(fields: [answerFreeInputId], references: [id], onDelete: Cascade)

  @@map("answer_option_selections")
}

model AnswerFreeInput {
  id            String        @id @default(uuid()) @db.Uuid
  dataType      FieldDataType @map("data_type")
  fieldAnswerId String        @map("field_answer_id") @db.Uuid
  value         String
  createdAt     DateTime      @default(now()) @map("created_at")

  FieldAnswer           FieldAnswer            @relation(fields: [fieldAnswerId], references: [id], onDelete: Cascade)
  AnswerOptionSelection AnswerOptionSelection?

  @@map("answer_free_inputs")
}

enum ResultType {
  Decision
  Ranking
  LlmSummary
  LlmSummaryList
}

// Describes how and when a final result is created
model ResultConfig {
  id         String     @id @default(uuid()) @db.Uuid
  resultType ResultType @map("result_type")
  // Minimum answers for a result to be created
  minAnswers Int        @default(0) @map("min_answers")
  // whether output will be a single item or a list of items
  createdAt  DateTime   @default(now()) @map("created_at")

  fieldId    String? @map("field_id") @db.Uuid
  decisionId String? @map("decision_id") @db.Uuid
  rankId     String? @map("rank_id") @db.Uuid
  llmId      String? @map("llm_id") @db.Uuid

  Field                        Field?                         @relation(fields: [fieldId], references: [id], onDelete: Cascade)
  ResultConfigDecision         ResultConfigDecision?          @relation(fields: [decisionId], references: [id], onDelete: Cascade)
  ResultConfigRank             ResultConfigRank?              @relation(fields: [rankId], references: [id], onDelete: Cascade)
  ResultConfigLlm              ResultConfigLlm?               @relation(fields: [llmId], references: [id], onDelete: Cascade)
  ResultGroups                 ResultGroup[]
  ResultConfigSetResultConfigs ResultConfigSetResultConfigs[]

  @@map("result_configs")
}

enum DecisionType {
  NumberThreshold
  PercentageThreshold
  WeightedAverage
  Ai
}

model ResultConfigDecision {
  id              String       @id @default(uuid()) @db.Uuid
  type            DecisionType
  defaultOptionId String?      @map("default_option_id") @db.Uuid
  // Threshold is interpreted as count when type is "threshold" and as a percentage when type is "Percentage"
  threshold       Int?         @map("threshold")
  criteria        String?
  createdAt       DateTime     @default(now()) @map("created_at")

  FieldOption   FieldOption?   @relation(fields: [defaultOptionId], references: [id], onDelete: Cascade)
  ResultConfigs ResultConfig[]

  @@map("result_config_decisions")
}

model ResultConfigRank {
  id                  String         @id @default(uuid()) @db.Uuid
  // null means include all options
  numOptionsToInclude Int?           @map("num_options")
  createdAt           DateTime       @default(now()) @map("created_at")
  ResultConfigs       ResultConfig[]

  @@map("result_config_rankings")
}

enum LlmSummaryType {
  AfterEveryResponse
  AtTheEnd
}

model ResultConfigLlm {
  id        String         @id @default(uuid()) @db.Uuid
  type      LlmSummaryType
  prompt    String
  example   String?
  createdAt DateTime       @default(now()) @map("created_at")

  ResultConfigs ResultConfig[]

  @@map("result_config_llms")
}

enum ActionType {
  CallWebhook
  TriggerStep
  EvolveFlow
  EvolveGroup
  GroupWatchFlow

  @@map("ActionType")
}

model Action {
  id                String       @id @default(uuid()) @db.Uuid
  type              ActionType
  webhookId         String?      @map("webhook_id") @db.Uuid
  filterOptionId    String?      @map("filter_option_id") @db.Uuid
  createdAt         DateTime     @default(now()) @map("created_at")
  // locked here means that the ActionType is locked. Other parts of the action can still be changed
  locked            Boolean      @default(false)
  Steps             Step[]       @relation("StepsWithAction")
  FilterFieldOption FieldOption? @relation(fields: [filterOptionId], references: [id], onDelete: Cascade)
  Webhook           Webhook?     @relation(fields: [webhookId], references: [id], onDelete: Cascade)

  ActionExecution ActionExecution[]

  @@map("actions")
}

model Webhook {
  id         String   @id @default(uuid()) @db.Uuid
  name       String
  uri        String
  uriPreview String   @map("uri_preview")
  createdAt  DateTime @default(now()) @map("created_at")

  Actions Action[]

  @@map("webhooks")
}

model ActionExecution {
  id              String    @id @default(uuid()) @db.Uuid
  actionId        String    @map("action_id") @db.Uuid
  requestStepId   String    @map("request_step_id") @db.Uuid
  complete        Boolean   @default(false)
  final           Boolean   @default(false)
  lastAttemptedAt DateTime  @default(now()) @map("last_attempted_at")
  retryAttempts   Int       @default(0) @map("retry_attempts")
  nextRetryAt     DateTime? @map("next_retry_at")
  createdAt       DateTime  @default(now()) @map("created_at")
  updatedAt       DateTime  @default(now()) @updatedAt @map("updated_at")

  Action      Action      @relation(fields: [actionId], references: [id], onDelete: Cascade)
  RequestStep RequestStep @relation(fields: [requestStepId], references: [id], onDelete: Cascade)

  @@unique([actionId, requestStepId])
  @@map("action_executions")
}

model Request {
  id                    String   @id @default(uuid()) @db.Uuid
  creatorEntityId       String   @map("creator_entity_id") @db.Uuid
  flowVersionId         String   @map("flow_version_id") @db.Uuid
  currentRequestStepId  String?  @unique @map("current_request_step_id") @db.Uuid
  name                  String
  final                 Boolean  @default(false)
  createdAt             DateTime @default(now()) @map("created_at")
  updatedAt             DateTime @default(now()) @updatedAt @map("updated_at")
  // if a request is an "evolve" request, this field will include the proposed flow version id
  proposedFlowVersionId String?  @unique @map("proposed_flow_version_id") @db.Uuid

  CreatorEntity                Entity       @relation(fields: [creatorEntityId], references: [id], onDelete: Cascade)
  FlowVersion                  FlowVersion  @relation("FlowVersion", fields: [flowVersionId], references: [id], onDelete: Cascade)
  ProposedFlowVersionEvolution FlowVersion? @relation("ProposedFlowVersionEvolution", fields: [proposedFlowVersionId], references: [id], onDelete: Cascade)
  CurrentRequestStep           RequestStep? @relation("CurrentRequestStep", fields: [currentRequestStepId], references: [id], onDelete: Cascade)

  // For when the options are request are created by the requestor or the previous step
  RequestSteps             RequestStep[]
  TriggerFieldAnswers      FieldAnswer[]
  RequestDefinedOptionSets RequestDefinedOptionSet[]

  @@map("requests")
}

model RequestStep {
  id             String   @id @default(uuid()) @db.Uuid
  requestId      String   @map("request_id") @db.Uuid
  stepId         String   @map("step_id") @db.Uuid
  responseFinal  Boolean  @default(false) @map("response_final")
  // 'final' results doesn't necessarily mean there are results, but rather that the step will no longer attempt to create results
  resultsFinal   Boolean  @default(false) @map("results_final")
  // 'final' action doesn't necessarily mean an action was successfully performed, but rather that the step will no longer attempt to run the action
  actionsFinal   Boolean  @default(false) @map("actions_final")
  // request Step is 'final' only if responseFinal, resultsFinal, and actionsFinal are all true
  final          Boolean  @default(false)
  expirationDate DateTime @map("expiration_date")
  createdAt      DateTime @default(now()) @map("created_at")
  updatedAt      DateTime @default(now()) @updatedAt @map("updated_at")

  Request           Request            @relation(fields: [requestId], references: [id], onDelete: Cascade)
  Step              Step               @relation(fields: [stepId], references: [id], onDelete: Cascade)
  CurrentStepParent Request?           @relation("CurrentRequestStep")
  ResultGroups      ResultGroup[]
  Responses         Response[]
  ActionExecution   ActionExecution[]
  TelegramMessages  TelegramMessages[]

  @@unique([stepId, requestId])
  @@map("request_steps")
}

model RequestDefinedOptionSet {
  id               String         @id @default(uuid()) @db.Uuid
  requestId        String         @map("request_step_id") @db.Uuid
  fieldId          String         @map("field_id") @db.Uuid
  fieldOptionSetId String         @map("field_option_set_id") @db.Uuid
  Request          Request        @relation(fields: [requestId], references: [id], onDelete: Cascade)
  Field            Field          @relation(fields: [fieldId], references: [id], onDelete: Cascade)
  FieldOptionSet   FieldOptionSet @relation(fields: [fieldOptionSetId], references: [id], onDelete: Cascade)

  @@map("request_defined_option_sets")
}

model Response {
  id              String   @id @default(uuid()) @db.Uuid
  requestStepId   String   @map("request_step_id") @db.Uuid
  // entity that created the response
  creatorEntityId String   @map("entity_id") @db.Uuid
  createdAt       DateTime @default(now()) @map("created_at")

  RequestStep   RequestStep   @relation(fields: [requestStepId], references: [id], onDelete: Cascade)
  Answers       FieldAnswer[]
  CreatorEntity Entity        @relation(fields: [creatorEntityId], references: [id], onDelete: Cascade)

  @@map("responses")
}

// List of fields for use in request or response
model ResultConfigSet {
  id                           String                         @id @default(uuid()) @db.Uuid
  createdAt                    DateTime                       @default(now()) @map("created_at")
  // FieldSetFields                  FieldSetsFields[]
  Step                         Step[]
  ResultConfigSetResultConfigs ResultConfigSetResultConfigs[]

  @@map("result_config_sets")
}

// Purpose of this association table is so that there can be new sets of options without 
// needing to create new fields everytime there's a change to the group (since data is immutable in Ize)
model ResultConfigSetResultConfigs {
  resultConfigSetId String @map("result_config_set_id") @db.Uuid
  resultConfigId    String @map("result_config_id") @db.Uuid

  ResultConfigSet ResultConfigSet @relation(fields: [resultConfigSetId], references: [id], onDelete: Cascade)
  ResultConfig    ResultConfig    @relation(fields: [resultConfigId], references: [id], onDelete: Cascade)

  @@unique([resultConfigId, resultConfigSetId])
  @@map("result_config_set_result_configs")
}

// there is a single results record for a given request step + results Config 
// so if a step has two result Configs, there will be two Results every time that Result rows
// A given result is associated with one or more result items (e.g. a single decision vs a prioritized list of options)
// The result model is an attempt of a result creation, but there may not actually be results in this attempt (e.g. the minimum vote threshold isn't hit for a decision)
model ResultGroup {
  id             String       @id @default(uuid()) @db.Uuid
  // final doesn't mean that there are results, but rather that there will be no more attempts to create a result for this resultConfig
  final          Boolean      @default(false)
  requestStepId  String       @map("request_step_id") @db.Uuid
  resultConfigId String       @map("result_config_id") @db.Uuid
  // Number of items within result array
  itemCount      Int          @map("itemCount")
  hasResult      Boolean      @map("has_result")
  retryAttempts  Int          @default(0) @map("retry_attempts")
  nextRetryAt    DateTime?    @map("next_retry_at")
  createdAt      DateTime     @default(now()) @map("created_at")
  updatedAt      DateTime     @default(now()) @updatedAt @map("updated_at")
  Result         Result[]
  RequestStep    RequestStep  @relation(fields: [requestStepId], references: [id], onDelete: Cascade)
  ResultConfig   ResultConfig @relation(fields: [resultConfigId], references: [id], onDelete: Cascade)

  @@unique([requestStepId, resultConfigId])
  @@map("result_groups")
}

model Result {
  id            String @id @default(uuid()) @db.Uuid
  itemCount     Int    @map("itemCount")
  resultGroupId String @map("result_group_id") @db.Uuid
  name          String

  // 0 index is primary result
  index Int

  ResultGroup ResultGroup   @relation(fields: [resultGroupId], references: [id], onDelete: Cascade)
  ResultItems ResultItems[]

  @@map("results")
}

model ResultItems {
  id            String        @id @default(uuid()) @db.Uuid
  value         String
  dataType      FieldDataType @map("data_type")
  fieldOptionId String?       @map("field_option_id") @db.Uuid
  resultId      String        @db.Uuid
  // used for ranking results. higher weight = stronger preference
  weight        Float         @default(1)
  createdAt     DateTime      @default(now()) @map("created_at")

  Result Result       @relation(fields: [resultId], references: [id], onDelete: Cascade)
  Option FieldOption? @relation(fields: [fieldOptionId], references: [id], onDelete: Cascade)

  @@map("result_items")
}

model EntityWatchedGroups {
  entityId String  @map("entity_id") @db.Uuid
  groupId  String  @map("group_id") @db.Uuid
  watched  Boolean

  Entity Entity @relation(fields: [entityId], references: [id], onDelete: Cascade)
  Group  Group  @relation(fields: [groupId], references: [id], onDelete: Cascade)

  @@unique([entityId, groupId])
  @@map("entity_watched_groups")
}

model EntityWatchedFlows {
  entityId String  @map("entity_id") @db.Uuid
  flowId   String  @map("flow_id") @db.Uuid
  watched  Boolean

  Flow   Flow   @relation(fields: [flowId], references: [id], onDelete: Cascade)
  Entity Entity @relation(fields: [entityId], references: [id], onDelete: Cascade)

  @@unique([entityId, flowId])
  @@map("entity_watched_flows")
}

model GroupsWatchedFlows {
  flowId  String  @map("flow_id") @db.Uuid
  groupId String  @map("group_id") @db.Uuid
  watched Boolean

  Flow  Flow  @relation(fields: [flowId], references: [id], onDelete: Cascade)
  Group Group @relation(fields: [groupId], references: [id], onDelete: Cascade)

  @@unique([flowId, groupId])
  @@map("groups_watched_flows")
}

model TelegramMessages {
  id            String  @id @default(uuid()) @db.Uuid
  chatId        BigInt  @map("chat_id")
  messageId     BigInt  @unique @map("message_id")
  pollId        BigInt? @unique @map("poll_id")
  requestStepId String  @map("request_step_id") @db.Uuid
  fieldId       String? @map("field_id") @db.Uuid

  createdAt DateTime @default(now()) @map("created_at")

  RequestStep RequestStep @relation(fields: [requestStepId], references: [id], onDelete: Cascade)
  Field       Field?      @relation(fields: [fieldId], references: [id], onDelete: Cascade)

  @@map("telegram_messages")
}

// model Notifications {
//   id String @id @default(uuid()) @db.Uuid

//   @@map("notifications")
// }
