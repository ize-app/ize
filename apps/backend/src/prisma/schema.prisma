generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id          String        @id @default(uuid()) @db.Uuid
  stytchId    String        @unique @map("stytch_id")
  firstName   String?
  lastName    String?
  createdAt   DateTime      @default(now()) @map("created_at")
  updatedAt   DateTime      @default(now()) @updatedAt @map("updated_at")
  Group       Group[]
  Identities  Identity[]
  Oauths      Oauths[]
  RequestNew  RequestNew[]
  ResponseNew ResponseNew[]
  Permission  Permission[]

  @@map("users")
}

model Identity {
  id        String   @id @default(uuid()) @db.Uuid
  userId    String?  @map("user_id") @db.Uuid
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @default(now()) @updatedAt @map("updated_at")
  // TODO make this field required
  entityId  String   @unique @map("entity_id") @db.Uuid

  User                        User?                       @relation(fields: [userId], references: [id], onDelete: Cascade)
  IdentityEmail               IdentityEmail?
  IdentityBlockchain          IdentityBlockchain?
  IdentityDiscord             IdentityDiscord?
  IdentitiesGroups            IdentityGroup[]
  CustomGroupMemberIdentities CustomGroupMemberIdentity[]
  Entity                      Entity                      @relation(fields: [entityId], references: [id], onDelete: Cascade)

  @@map("identities")
}

model IdentityEmail {
  id         String   @id @default(uuid()) @db.Uuid
  identityId String   @unique @map("identity_id") @db.Uuid
  email      String   @unique
  icon       String?
  createdAt  DateTime @default(now()) @map("created_at")
  updatedAt  DateTime @default(now()) @updatedAt @map("updated_at")

  Identity Identity @relation(fields: [identityId], references: [id], onDelete: Cascade)

  @@map("identities_email")
}

model IdentityBlockchain {
  id         String   @id @default(uuid()) @db.Uuid
  identityId String   @unique @map("identity_id") @db.Uuid
  address    String   @unique
  ens        String?
  createdAt  DateTime @default(now()) @map("created_at")
  updatedAt  DateTime @default(now()) @updatedAt @map("updated_at")

  Identity Identity @relation(fields: [identityId], references: [id], onDelete: Cascade)

  @@map("identities_blockchain")
}

model IdentityDiscord {
  id            String   @id @default(uuid()) @db.Uuid
  identityId    String   @unique @map("identity_id") @db.Uuid
  discordUserId String   @map("discord_user_id")
  username      String
  discriminator String
  avatar        String?
  createdAt     DateTime @default(now()) @map("created_at")
  updatedAt     DateTime @default(now()) @updatedAt @map("updated_at")

  Identity Identity @relation(fields: [identityId], references: [id], onDelete: Cascade)

  @@map("identities_discord")
}

model IdentityGroup {
  identityId String   @map("identity_id") @db.Uuid
  groupId    String   @map("group_id") @db.Uuid
  active     Boolean
  createdAt  DateTime @default(now()) @map("created_at")
  updatedAt  DateTime @default(now()) @updatedAt @map("updated_at")

  Identity Identity @relation(fields: [identityId], references: [id], onDelete: Cascade)
  Group    Group    @relation(fields: [groupId], references: [id], onDelete: Cascade)

  @@unique([identityId, groupId])
  @@map("identities_groups")
}

enum OauthTypes {
  Discord
  Google
}

model Oauths {
  userId       String     @map("user_id") @db.Uuid
  type         OauthTypes
  accessToken  String     @map("access_token")
  refreshToken String     @map("refresh_token")
  idToken      String?    @map("id_token")
  scopes       Json[]
  expiresAt    DateTime?  @map("expires_at")
  createdAt    DateTime   @default(now()) @map("created_at")
  updatedAt    DateTime   @default(now()) @updatedAt @map("updated_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id(name: "id", [userId, type])
  @@map("oauths")
}

model Group {
  id                      String                   @id @default(uuid()) @db.Uuid
  creator                 User                     @relation(fields: [creatorId], references: [id])
  creatorId               String                   @map("creator_id") @db.Uuid
  entityId                String                   @unique @map("entity_id") @db.Uuid
  createdAt               DateTime                 @default(now()) @map("created_at")
  updatedAt               DateTime                 @default(now()) @updatedAt @map("updated_at")
  activeAt                DateTime?
  deactivatedat           DateTime?
  Entity                  Entity                   @relation(fields: [entityId], references: [id], onDelete: Cascade)
  GroupDiscordRole        GroupDiscordRole?
  GroupNft                GroupNft?
  IdentitiesGroups        IdentityGroup[]
  CustomGroupMemberGroups CustomGroupMemberGroup[]
  GroupCustom             GroupCustom?

  @@map("groups")
}

model GroupDiscordRole {
  id              String        @id @default(uuid()) @db.Uuid
  discordRoleId   String?       @map("discord_role_id")
  Group           Group         @relation(fields: [groupId], references: [id], onDelete: Cascade)
  groupId         String        @unique @map("group_id") @db.Uuid
  discordServer   DiscordServer @relation(fields: [discordServerId], references: [id], onDelete: Cascade)
  discordServerId String        @map("discord_server_id") @db.Uuid
  color           Int?
  name            String
  icon            String?
  unicodeEmoji    String?       @map("unicode_emoji")
  memberCount     Int?          @map("member_count")
  createdAt       DateTime      @default(now()) @map("created_at")
  updatedAt       DateTime      @default(now()) @updatedAt @map("updated_at")

  @@unique([discordServerId, discordRoleId])
  @@unique([discordServerId, name])
  @@map("discord_role_groups")
}

enum NftTypes {
  ERC721
  ERC1155
}

enum Blockchain {
  Ethereum
  Arbitrum
  Optimism
  Matic
  Base
}

model GroupCustom {
  id      String @id @default(uuid()) @db.Uuid
  name    String
  groupId String @unique @map("group_id") @db.Uuid

  group                       Group                       @relation(fields: [groupId], references: [id], onDelete: Cascade)
  CustomGroupMemberIdentities CustomGroupMemberIdentity[]
  CustomGroupMemberGroups     CustomGroupMemberGroup[]

  @@map("groups_custom")
}

model CustomGroupMemberGroup {
  groupId       String      @map("group_id") @db.Uuid
  groupCustomId String      @map("group_custom_id") @db.Uuid
  Group         Group       @relation(fields: [groupId], references: [id], onDelete: Cascade)
  GroupCustom   GroupCustom @relation(fields: [groupCustomId], references: [id], onDelete: Cascade)

  @@unique([groupId, groupCustomId])
  @@map("custom_group_group_members")
}

model CustomGroupMemberIdentity {
  identityId    String      @map("identity_id") @db.Uuid
  groupCustomId String      @map("group_custom_id") @db.Uuid
  Identity      Identity    @relation(fields: [identityId], references: [id], onDelete: Cascade)
  GroupCustom   GroupCustom @relation(fields: [groupCustomId], references: [id], onDelete: Cascade)

  @@unique([identityId, groupCustomId])
  @@map("custom_group_identity_members")
}

model GroupNft {
  id           String  @id @default(uuid()) @db.Uuid
  name         String
  icon         String?
  groupId      String  @unique @map("group_id") @db.Uuid
  collectionId String  @map("collection_id") @db.Uuid
  // null tokenId means that this group applies to all tokens in that collection
  tokenId      String? @map("token_id")

  Group         Group         @relation(fields: [groupId], references: [id], onDelete: Cascade)
  NftCollection NftCollection @relation(fields: [collectionId], references: [id], onDelete: Cascade)

  @@unique([collectionId, tokenId])
  @@map("groups_nft")
}

model NftCollection {
  id       String     @id @default(uuid()) @db.Uuid
  name     String?
  icon     String?
  chain    Blockchain
  type     NftTypes
  address  String
  GroupNft GroupNft[]

  @@unique([chain, address])
  @@map("nft_collection")
}

model DiscordServer {
  id               String             @id @default(uuid()) @db.Uuid
  discordServerId  String             @unique @map("discord_server_id")
  name             String
  icon             String?
  banner           String?
  createdAt        DateTime           @default(now()) @map("created_at")
  updatedAt        DateTime           @default(now()) @updatedAt @map("updated_at")
  GroupDiscordRole GroupDiscordRole[]

  @@map("discord_servers")
}

enum FlowType {
  Custom
  Evolve
}

model Flow {
  id   String   @id @default(uuid()) @db.Uuid
  type FlowType

  currentFlowVersionId String? @unique @map("current_flow_version_id") @db.Uuid

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @default(now()) @updatedAt @map("updated_at")

  CurrentFlowVersion         FlowVersion?  @relation("FlowToCurrentFlowVersion", fields: [currentFlowVersionId], references: [id])
  FlowVersions               FlowVersion[] @relation("FlowToAllFlowVersions")
  EvolveRightsFoFlowVersions FlowVersion[] @relation("EvolveFlowToFlowVersions")

  @@map("flows")
}

model FlowVersion {
  id           String  @id @default(uuid()) @db.Uuid
  name         String
  reusable     Boolean
  flowId       String  @map("flow_id") @db.Uuid
  // the evolve flow id gives evolve flow edit rights over all steps in the flow
  evolveFlowId String? @map("evolve_flow_id") @db.Uuid

  createdAt DateTime @default(now()) @map("created_at")

  FlowForCurrentVersion Flow?        @relation("FlowToCurrentFlowVersion")
  Flow                  Flow         @relation("FlowToAllFlowVersions", fields: [flowId], references: [id], onDelete: Cascade)
  EvolveFlow            Flow?        @relation("EvolveFlowToFlowVersions", fields: [evolveFlowId], references: [id], onDelete: Cascade)
  Steps                 Step[]
  RequestNew            RequestNew[]

  @@map("flow_versions")
}

// Note: In this current model, steps are tied to a given workflow,
// If in the future, we wanted to allow steps to be reusable by different flows while preserving flow data immutability,
// we'd need to create a steps_versions_model and flows_versions_steps model.
// Too much complexity for v1
model Step {
  id                    String  @id @default(uuid()) @db.Uuid
  flowVersionId         String  @map("flow_version_id") @db.Uuid
  index                 Int
  expirationSeconds     Int?    @default(0) @map("request_expiration_seconds")
  requestPermissionsId  String  @map("request_permissions_id") @db.Uuid
  responsePermissionsId String? @map("response_permissions_id") @db.Uuid
  requestFieldSetId     String? @map("request_field_set_id") @db.Uuid
  responseFieldSetId    String? @map("response_field_set_id") @db.Uuid
  resultConfigSetId     String? @map("result_config_set_id") @db.Uuid

  actionId  String?  @map("action_id") @db.Uuid
  createdAt DateTime @default(now()) @map("created_at")

  FlowVersion         FlowVersion      @relation(fields: [flowVersionId], references: [id], onDelete: Cascade)
  RequestPermissions  Permission       @relation("RequestPermissions", fields: [requestPermissionsId], references: [id], onDelete: Cascade)
  RequestFieldSet     FieldSet?        @relation("RequestFieldSet", fields: [requestFieldSetId], references: [id], onDelete: Cascade)
  ResponseFieldSet    FieldSet?        @relation("ResponseFieldSet", fields: [responseFieldSetId], references: [id], onDelete: Cascade)
  ResponsePermissions Permission?      @relation("ResponsePermissions", fields: [responsePermissionsId], references: [id], onDelete: Cascade)
  ResultConfigSet     ResultConfigSet? @relation(fields: [resultConfigSetId], references: [id])

  ActionNew   ActionNew?    @relation("StepsWithAction", fields: [actionId], references: [id], onDelete: Cascade)
  RequestStep RequestStep[]

  @@map("steps")
}

model Permission {
  id String @id @default(uuid()) @db.Uuid

  entitySetId   String?  @map("entity_set_id") @db.Uuid
  stepTriggered Boolean  @map("step_triggered")
  anyone        Boolean  @default(false)
  userId        String?  @map("user_id") @db.Uuid
  createdAt     DateTime @default(now()) @map("created_at")

  EntitySet                EntitySet? @relation(fields: [entitySetId], references: [id], onDelete: Cascade)
  RequestPermissionsSteps  Step[]     @relation("RequestPermissions")
  ResponsePermissionsSteps Step[]     @relation("ResponsePermissions")
  // Refers to when a a particular Ize user's permission on a given flow
  User                     User?      @relation(fields: [userId], references: [id])

  @@map("permissions")
}

model EntitySet {
  id                String              @id @default(uuid()) @db.Uuid
  Permissions       Permission[]
  createdAt         DateTime            @default(now()) @map("created_at")
  EntitySetEntities EntitySetEntities[]

  @@map("entity_sets")
}

model EntitySetEntities {
  entitySetId String @map("entity_set_id") @db.Uuid
  entityId    String @map("entity_id") @db.Uuid

  EntitySet EntitySet @relation(fields: [entitySetId], references: [id], onDelete: Cascade)
  Entity    Entity    @relation(fields: [entityId], references: [id], onDelete: Cascade)

  @@unique([entityId, entitySetId])
  @@map("entity_set_entities")
}

// Entities are anything that can be assigned a role. 
// For now, that's goups and identities
model Entity {
  id        String   @id @default(uuid()) @db.Uuid
  createdAt DateTime @default(now()) @map("created_at")

  Group             Group?
  Identity          Identity?
  EntitySetEntities EntitySetEntities[]

  @@map("entities")
}

// List of fields for use in request or response
model FieldSet {
  id                              String            @id @default(uuid()) @db.Uuid
  createdAt                       DateTime          @default(now()) @map("created_at")
  StepsRequestsUsingThisFieldSet  Step[]            @relation("RequestFieldSet")
  StepsResponsesUsingThisFieldSet Step[]            @relation("ResponseFieldSet")
  FieldSetFields                  FieldSetsFields[]

  @@map("field_sets")
}

// Purpose of this association table is so that there can be new sets of options without 
// needing to create new fields everytime there's a change to the group (since data is immutable in Ize)
model FieldSetsFields {
  fieldSetId String @map("field_set_id") @db.Uuid
  fieldId    String @map("field_id") @db.Uuid

  FieldSet FieldSet @relation(fields: [fieldSetId], references: [id], onDelete: Cascade)
  Field    Field    @relation(fields: [fieldId], references: [id], onDelete: Cascade)

  @@unique([fieldId, fieldSetId])
  @@map("field_sets_fields")
}

enum FieldDataType {
  String
  Number
  Uri
  Date
  DateTime
}

enum FieldType {
  Options
  FreeInput
}

// Describes a single ask for a users input (e.g. select an option)
model Field {
  id                   String         @id @default(uuid()) @db.Uuid
  type                 FieldType
  name                 String
  required             Boolean        @default(true)
  freeInputDataType    FieldDataType? @map("free_input_data_type")
  fieldOptionsConfigId String?        @map("field_options_config_id") @db.Uuid
  createdAt            DateTime       @default(now()) @map("created_at")

  FieldOptionsConfigs     FieldOptionsConfig?       @relation(fields: [fieldOptionsConfigId], references: [id])
  Answers                 FieldAnswer[]
  ResultConfig            ResultConfig[]
  FieldSetFields          FieldSetsFields[]
  RequestDefinedOptionSet RequestDefinedOptionSet[]

  @@map("fields")
}

enum OptionSelectionType {
  Rank
  MultiSelect
  Select
}

// Describes how a set of options are created on a request 
model FieldOptionsConfig {
  id                     String              @id @default(uuid()) @db.Uuid
  fieldOptionSetId       String              @map("field_option_set_id") @db.Uuid
  requestOptionsDataType FieldDataType?      @map("data_type")
  // Whether or not options are created by the requestor
  hasRequestOptions      Boolean             @default(false) @map("has_request_options")
  previousStepOptions    Boolean             @default(false) @map("previous_step_options")
  // Whether option is single or multi-select
  maxSelections          Int                 @map("max_selections")
  linkedResultOptions    String[]            @default([]) @map("linked_result_options")
  // type single select / multi-select / etc
  selectionType          OptionSelectionType @map("option_selection_type")
  createdAt              DateTime            @default(now()) @map("created_at")

  Field          Field[]
  FieldOptionSet FieldOptionSet @relation(fields: [fieldOptionSetId], references: [id], onDelete: Cascade)

  @@map("field_options_configs")
}

model FieldOptionSet {
  id        String   @id @default(uuid()) @db.Uuid
  createdAt DateTime @default(now()) @map("created_at")

  FieldOptionsConfigs        FieldOptionsConfig[]
  FieldOptionSetFieldOptions FieldOptionSetsFieldOptions[]
  RequestDefinedOptionSet    RequestDefinedOptionSet[]

  @@map("field_option_sets")
}

// Purpose of this association table is so that there can be new sets of options without 
// needing to create new options everytime there's a change to the group (since data is immutable in Ize)
// This makes showing diffs between flow versions much eaiser
model FieldOptionSetsFieldOptions {
  fieldOptionSetId String @map("field_option_set_id") @db.Uuid
  fieldOptionId    String @map("field_option_id") @db.Uuid
  // The order that the option should be displayed
  index            Int

  FieldOptionSet FieldOptionSet @relation(fields: [fieldOptionSetId], references: [id], onDelete: Cascade)
  FieldOption    FieldOption    @relation(fields: [fieldOptionId], references: [id], onDelete: Cascade)

  @@unique([fieldOptionId, fieldOptionSetId])
  @@unique([index, fieldOptionSetId])
  @@map("field_option_set_field_options")
}

model FieldOption {
  id        String        @id @default(uuid()) @db.Uuid
  dataType  FieldDataType @map("data_type")
  name      String
  createdAt DateTime      @default(now()) @map("created_at")

  AnswerOptionSelections     AnswerOptionSelection[]
  FieldOptionSetFieldOptions FieldOptionSetsFieldOptions[]
  DefaultOptionForDecisions  ResultConfigDecision[]
  ActionNew                  ActionNew[]
  ResultItems                ResultItems[]

  @@map("field_options")
}

// An answer is either an array of free input responses or option selections for a given field
model FieldAnswer {
  id            String    @id @default(uuid()) @db.Uuid
  type          FieldType
  responseId    String?   @map("response_id") @db.Uuid
  requestStepId String?   @map("request_step_id") @db.Uuid
  fieldId       String    @map("field_id") @db.Uuid
  createdAt     DateTime  @default(now()) @map("created_at")

  Field                  Field                   @relation(fields: [fieldId], references: [id], onDelete: Cascade)
  Response               ResponseNew?            @relation(fields: [responseId], references: [id], onDelete: Cascade)
  Request                RequestStep?            @relation(fields: [requestStepId], references: [id], onDelete: Cascade)
  AnswerOptionSelections AnswerOptionSelection[]
  AnswerFreeInput        AnswerFreeInput[]

  @@map("answers")
}

model AnswerOptionSelection {
  id                String   @id @default(uuid()) @db.Uuid
  fieldAnswerId     String   @map("field_answer_id") @db.Uuid
  fieldOptionId     String   @map("field_option_id") @db.Uuid
  answerFreeInputId String?  @unique @map("answer_free_input_id") @db.Uuid
  createdAt         DateTime @default(now()) @map("created_at")

  FieldOption     FieldOption      @relation(fields: [fieldOptionId], references: [id], onDelete: Cascade)
  FieldAnswer     FieldAnswer      @relation(fields: [fieldAnswerId], references: [id], onDelete: Cascade)
  AnswerFreeInput AnswerFreeInput? @relation(fields: [answerFreeInputId], references: [id], onDelete: Cascade)

  @@map("answer_option_selections")
}

model AnswerFreeInput {
  id            String        @id @default(uuid()) @db.Uuid
  dataType      FieldDataType @map("data_type")
  fieldAnswerId String        @map("field_answer_id") @db.Uuid
  value         String
  createdAt     DateTime      @default(now()) @map("created_at")

  FieldAnswer           FieldAnswer            @relation(fields: [fieldAnswerId], references: [id], onDelete: Cascade)
  AnswerOptionSelection AnswerOptionSelection?

  @@map("answer_free_inputs")
}

enum ResultType {
  Raw
  Decision
  Ranking
  LlmSummary
  AutoApprove
}

// Describes how and when a final result is created
model ResultConfig {
  id         String     @id @default(uuid()) @db.Uuid
  resultType ResultType @map("result_type")
  // Minimum answers for a result to be created
  minAnswers Int        @default(0) @map("min_answers")
  // whether output will be a single item or a list of items
  createdAt  DateTime   @default(now()) @map("created_at")

  fieldId    String? @map("field_id") @db.Uuid
  decisionId String? @map("decision_id") @db.Uuid
  rankId     String? @map("rank_id") @db.Uuid
  llmId      String? @map("llm_id") @db.Uuid

  Field                        Field?                         @relation(fields: [fieldId], references: [id], onDelete: Cascade)
  ResultConfigDecision         ResultConfigDecision?          @relation(fields: [decisionId], references: [id], onDelete: Cascade)
  ResultConfigRank             ResultConfigRank?              @relation(fields: [rankId], references: [id], onDelete: Cascade)
  ResultConfigLlm              ResultConfigLlm?               @relation(fields: [llmId], references: [id], onDelete: Cascade)
  Results                      ResultsNew[]
  ResultConfigSetResultConfigs ResultConfigSetResultConfigs[]

  @@map("result_configs")
}

enum DecisionType {
  NumberThreshold
  PercentageThreshold
}

model ResultConfigDecision {
  id              String       @id @default(uuid()) @db.Uuid
  type            DecisionType
  defaultOptionId String?      @map("default_option_id") @db.Uuid
  // Threshold is interpreted as count when type is "threshold" and as a percentage when type is "Percentage"
  threshold       Int          @map("threshold")
  createdAt       DateTime     @default(now()) @map("created_at")

  FieldOption   FieldOption?   @relation(fields: [defaultOptionId], references: [id], onDelete: Cascade)
  ResultConfigs ResultConfig[]

  @@map("result_config_decisions")
}

model ResultConfigRank {
  id                  String         @id @default(uuid()) @db.Uuid
  // null means include all options
  numOptionsToInclude Int            @map("num_options")
  createdAt           DateTime       @default(now()) @map("created_at")
  ResultConfigs       ResultConfig[]

  @@map("result_config_rankings")
}

enum LlmSummaryType {
  AfterEveryResponse
  AtTheEnd
}

model ResultConfigLlm {
  id        String         @id @default(uuid()) @db.Uuid
  type      LlmSummaryType
  prompt    String?
  createdAt DateTime       @default(now()) @map("created_at")

  ResultConfigs ResultConfig[]

  @@map("result_config_llms")
}

enum ActionNewType {
  CallWebhook
  TriggerStep
  EvolveFlow
}

model ActionNew {
  id             String        @id @default(uuid()) @db.Uuid
  type           ActionNewType
  webhookId      String?       @map("webhook_id") @db.Uuid
  filterOptionId String?       @map("filter_option_id") @db.Uuid
  createdAt      DateTime      @default(now()) @map("created_at")

  Steps             Step[]       @relation("StepsWithAction")
  FilterFieldOption FieldOption? @relation(fields: [filterOptionId], references: [id], onDelete: Cascade)
  Webhook           Webhook?     @relation(fields: [webhookId], references: [id], onDelete: Cascade)

  ActionExecution ActionExecution[]

  @@map("actions_new")
}

model Webhook {
  id        String   @id @default(uuid()) @db.Uuid
  name      String
  uri       String
  createdAt DateTime @default(now()) @map("created_at")

  ActionsNew ActionNew[]

  @@map("webhooks")
}

model ActionExecution {
  id              String   @id @default(uuid()) @db.Uuid
  actionId        String   @map("action_id") @db.Uuid
  requestStepId   String   @map("request_step_id") @db.Uuid
  complete        Boolean  @default(false)
  lastAttemptedAt DateTime @default(now()) @map("last_attempted_at")
  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @default(now()) @updatedAt @map("updated_at")

  Action      ActionNew   @relation(fields: [actionId], references: [id], onDelete: Cascade)
  RequestStep RequestStep @relation(fields: [requestStepId], references: [id])

  @@unique([actionId, requestStepId])
  @@map("action_attempts_new")
}

model RequestNew {
  id                   String   @id @default(uuid()) @db.Uuid
  creatorId            String   @map("creator_id") @db.Uuid
  flowVersionId        String   @map("flow_version_id") @db.Uuid
  currentRequestStepId String?  @unique @map("current_request_step_id") @db.Uuid
  name                 String
  open                 Boolean  @default(true)
  createdAt            DateTime @default(now()) @map("created_at")
  updatedAt            DateTime @default(now()) @updatedAt @map("updated_at")

  FlowVersion        FlowVersion  @relation(fields: [flowVersionId], references: [id])
  Creator            User         @relation(fields: [creatorId], references: [id])
  CurrentRequestStep RequestStep? @relation("CurrentRequestStep", fields: [currentRequestStepId], references: [id])

  // For when the options are request are created by the requestor or the previous step
  RequestSteps RequestStep[]

  @@map("requests_new")
}

model RequestStep {
  id              String   @id @default(uuid()) @db.Uuid
  requestId       String   @map("request_id") @db.Uuid
  stepId          String   @map("step_id") @db.Uuid
  expired         Boolean  @default(false)
  resultsComplete Boolean  @default(false) @map("results_complete")
  actionsComplete Boolean  @default(false) @map("actions_complete")
  expirationDate  DateTime @map("expiration_date")
  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @default(now()) @updatedAt @map("updated_at")

  Request                  RequestNew                @relation(fields: [requestId], references: [id])
  Step                     Step                      @relation(fields: [stepId], references: [id])
  CurrentStepParent        RequestNew?               @relation("CurrentRequestStep")
  RequestFieldAnswers      FieldAnswer[]
  Results                  ResultsNew[]
  RequestDefinedOptionSets RequestDefinedOptionSet[]
  Responses                ResponseNew[]
  ActionExecution          ActionExecution[]

  @@unique([stepId, requestId])
  @@map("request_steps")
}

model RequestDefinedOptionSet {
  id               String         @id @default(uuid()) @db.Uuid
  requestStepId    String         @map("request_step_id") @db.Uuid
  fieldId          String         @map("field_id") @db.Uuid
  fieldOptionSetId String         @map("field_option_set_id") @db.Uuid
  RequestStep      RequestStep    @relation(fields: [requestStepId], references: [id])
  Field            Field          @relation(fields: [fieldId], references: [id])
  FieldOptionSet   FieldOptionSet @relation(fields: [fieldOptionSetId], references: [id])

  @@map("request_defined_option_sets")
}

model ResponseNew {
  id            String   @id @default(uuid()) @db.Uuid
  requestStepId String   @map("request_step_id") @db.Uuid
  creatorId     String   @map("creator_id") @db.Uuid
  createdAt     DateTime @default(now()) @map("created_at")

  RequestStep RequestStep   @relation(fields: [requestStepId], references: [id])
  Answers     FieldAnswer[]
  User        User          @relation(fields: [creatorId], references: [id])

  @@map("responses_new")
}

// List of fields for use in request or response
model ResultConfigSet {
  id                           String                         @id @default(uuid()) @db.Uuid
  createdAt                    DateTime                       @default(now()) @map("created_at")
  // FieldSetFields                  FieldSetsFields[]
  Step                         Step[]
  ResultConfigSetResultConfigs ResultConfigSetResultConfigs[]

  @@map("result_config_sets")
}

// Purpose of this association table is so that there can be new sets of options without 
// needing to create new fields everytime there's a change to the group (since data is immutable in Ize)
model ResultConfigSetResultConfigs {
  resultConfigSetId String @map("result_config_set_id") @db.Uuid
  resultConfigId    String @map("result_config_id") @db.Uuid

  ResultConfigSet ResultConfigSet @relation(fields: [resultConfigSetId], references: [id])
  ResultConfig    ResultConfig    @relation(fields: [resultConfigId], references: [id])

  @@unique([resultConfigId, resultConfigSetId])
  @@map("result_config_set_result_configs")
}

// there is a single results record for a given request step + results Config 
// so if a step has two result Configs, there will be two Results every time that Result rows
// A given result is associated with one or more result items (e.g. a single decision vs a prioritized list of options)
model ResultsNew {
  id             String   @id @default(uuid()) @db.Uuid
  complete       Boolean  @default(false)
  requestStepId  String   @map("request_step_id") @db.Uuid
  resultConfigId String   @map("result_config_id") @db.Uuid
  // Number of items within result array
  itemCount      Int      @map("itemCount")
  createdAt      DateTime @default(now()) @map("created_at")
  updatedAt      DateTime @default(now()) @updatedAt @map("updated_at")

  RequestStep  RequestStep   @relation(fields: [requestStepId], references: [id])
  ResultConfig ResultConfig  @relation(fields: [resultConfigId], references: [id])
  ResultItems  ResultItems[]

  @@map("results_new")
}

model ResultItems {
  id            String        @id @default(uuid()) @db.Uuid
  value         String
  dataType      FieldDataType @map("data_type")
  fieldOptionId String?       @map("field_option_id") @db.Uuid
  resultId      String        @db.Uuid
  createdAt     DateTime      @default(now()) @map("created_at")

  Result ResultsNew   @relation(fields: [resultId], references: [id])
  Option FieldOption? @relation(fields: [fieldOptionId], references: [id])

  @@map("result_items")
}
