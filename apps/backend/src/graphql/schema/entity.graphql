input setUpDiscordServerInput {
  serverId: String!
  roleId: String
}

type Mutation {
  newCustomGroup(inputs: CustomGroupArgs!): String!
  newEntities(entities: [NewEntityArgs!]!): [Entity!]!
}

type Query {
  group(id: String!): IzeGroup!
  groupsForCurrentUser(
    cursor: String
    limit: Int!
    searchQuery: String!
    watchFilter: WatchFilter!
  ): [Group!]!
}

enum NewEntityTypes {
  IdentityBlockchain
  IdentityDiscord
  IdentityEmail
  GroupDiscord
  GroupNft
  GroupHat
  GroupTelegramChat
}

enum EntityType {
  Group
  Identity
  User
}

union Entity = Identity | Group | User

union IdentityType = IdentityBlockchain | IdentityEmail | IdentityDiscord | IdentityTelegram

type Identity {
  id: String! # refers to id of Identity model
  name: String!
  icon: String
  entityId: String!
  identityType: IdentityType!
}

type IdentityBlockchain {
  id: String!
  address: String!
}

type IdentityEmail {
  id: String!
  icon: String
  email: String!
}

type IdentityDiscord {
  id: String!
  avatar: String
  username: String!
  discordUserId: String!
}

type IdentityTelegram {
  id: String!
  telegramUserId: String!
  photo: String
  firstName: String!
  lastName: String
  telegramUsername: String
}

union GroupType = DiscordRoleGroup | GroupNft | GroupIze | GroupTelegramChat

type Group {
  id: String!
  entityId: String!
  name: String!
  color: String
  icon: String
  memberCount: Int
  organization: Organization
  createdAt: String!
  groupType: GroupType!
  isMember: Boolean!
  isWatched: Boolean!
}

# IzeGroup only applies to the GroupIze entity type
# IzeGroup is a more fully hydrated version of this entity
# TODO: There's probably a more elegant way to model this
type IzeGroup {
  group: Group!
  members: [Entity!]!
  description: String
  notificationEntity: Entity
  evolveGroupFlowId: String
}

type Organization {
  name: String!
  icon: String
}

type GroupIze {
  id: String!
  name: String!
}

type GroupNft {
  id: String!
  name: String!
  icon: String
  tokenId: String
  NftCollection: NftCollection!
}

type NftCollection {
  id: String!
  name: String
  icon: String
  chain: Blockchain!
  type: NftTypes!
  address: String!
}

type DiscordRoleGroup {
  id: String!
  name: String!
  color: Int
  icon: String
  memberCount: Int
  unicodeEmoji: String
  discordRoleId: String
  discordServer: OnboardedDiscordServer!
}

type GroupTelegramChat {
  id: String!
  name: String!
  icon: String
  chatId: String!
  messageThreadId: String
}

type OnboardedDiscordServer {
  id: String!
  discordServerId: String!
  name: String!
  icon: String
  banner: String
}

# used for associating an existing entity with some other object
input EntityArgs {
  # refers to entityId
  id: String!
}

input IdentityBlockchainArgs {
  address: String!
}

input IdentityDiscordArgs {
  discordUserId: String!
}

input IdentityEmailArgs {
  email: String!
}

enum GroupFlowPolicyType {
  CreatorAutoApprove
  GroupAutoApprove
  GroupDecision
}

input GroupFlowPolicyArgs {
  type: GroupFlowPolicyType!
  decision: DecisionArgs
}

input GroupFlowArgs {
  evolveGroup: GroupFlowPolicyArgs!
  watch: GroupFlowPolicyArgs!
}

input CustomGroupArgs {
  entityId: String!
  name: String!
  description: String
  members: [EntityArgs!]!
  flows: GroupFlowArgs!
  notificationEntity: EntityArgs
}

input NewEntityArgs {
  identityBlockchain: IdentityBlockchainArgs
  identityDiscord: IdentityDiscordArgs
  identityEmail: IdentityEmailArgs
  groupDiscordRole: GroupDiscordRoleArgs
  groupEns: GroupEnsArgs
  groupHat: GroupHatArgs
  groupNft: GroupNftArgs
}

input GroupDiscordRoleArgs {
  serverId: String!
  roleId: String!
}

input GroupNftArgs {
  chain: Blockchain!
  address: String!
  tokenId: String
}

input GroupEnsArgs {
  name: String!
}

input GroupHatArgs {
  chain: Blockchain!
  tokenId: String!
}
