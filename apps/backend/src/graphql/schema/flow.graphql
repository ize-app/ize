type Mutation {
  newFlow(newFlow: NewFlowMutationArgs!): String!
}

type Query {
  getFlow(flowId: String, flowVersionId: String, isForEvolveRequest: Boolean): Flow!
  getGroupsToWatchFlow(flowId: String, entities: [String!]!): GroupsToWatch!
  getFlows(
    cursor: String
    limit: Int!
    groupId: String
    searchQuery: String!
    watchedByUserGroups: Boolean!
    watchedByUser: Boolean!
    createdByUser: Boolean!
    excludeGroupId: String
    hasTriggerPermissions: Boolean!
  ): [FlowSummary!]!
}

type Flow {
  id: String!
  flowId: String!
  flowVersionId: String!
  currentFlowVersionId: String
  group: Group
  createdAt: String!
  versionCreatedAt: String!
  versionPublishedAt: String
  active: Boolean!
  type: FlowType!
  name: String!
  reusable: Boolean!
  fieldSet: FieldSet!
  trigger: TriggerConfig!
  steps: [Step!]!
  flowsEvolvedByThisFlow: [FlowReference!]!
  evolve: Flow
  watching: FlowWatchers!
}

type FlowSummary {
  flowId: String!
  name: String!
  group: Group
  creator: Entity!
  createdAt: String!
  # permission to trigger first step of the flow
  trigger: TriggerConfig!
  watching: FlowWatchers!
}

type FlowReference {
  flowId: String!
  flowVersionId: String!
  flowName: String!
}

enum FlowType {
  Custom
  Evolve
  EvolveGroup
  GroupWatchFlow
}

type TriggerConfig {
  permission: Permission!
  userPermission: Boolean!
}

type Step {
  id: String!
  index: Int!
  fieldSet: FieldSet!
  response: ResponseConfig
  result: [ResultConfig!]!
  action: Action
}

type ResponseConfig {
  permission: Permission!
  expirationSeconds: Int!
  canBeManuallyEnded: Boolean!
  allowMultipleResponses: Boolean!
  # whether or not that particular user has permission to respond
  userPermission: Boolean!
  minResponses: Int!
}

input NewFlowMutationArgs {
  new: NewFlowWithEvolveArgs!
  groupsToWatch: [String!]!
  # only used if flow is non-reusable (which means initial request is triggered automatically)
  requestName: String
}

input NewFlowWithEvolveArgs {
  flow: NewFlowArgs!
  evolve: NewFlowArgs
  reusable: Boolean!
}

input NewFlowArgs {
  flowVersionId: String!
  type: FlowType!
  name: String!
  steps: [NewStepArgs!]!
  fieldSet: FieldSetArgs!
  trigger: TriggerConfigArgs!
}

input NewStepArgs {
  stepId: String!
  fieldSet: FieldSetArgs!
  response: ResponseConfigArgs
  result: [ResultArgs!]!
  action: ActionArgs
}

input TriggerConfigArgs {
  permission: PermissionArgs!
}

input ResponseConfigArgs {
  permission: PermissionArgs!
  expirationSeconds: Int!
  allowMultipleResponses: Boolean!
  canBeManuallyEnded: Boolean!
  minResponses: Int!
}

type FlowWatchers {
  user: Boolean!
  groups: [Group!]!
}

type GroupsToWatch {
  relevantGroups: [Group!]!
  otherGroups: [Group!]!
}

enum FlowWatchFilter {
  WatchedByMe
  WatchedByMeOrMyGroups
  NotWatching
  All
}
